<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CS106B note</title>
    <url>/2022/11/26/CS106B-note/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h3><p>ADT（Abstract Data Type，抽象数据类型）</p>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p>《Programming Abstraction in C++ - Eric Roberts》<br>中文版 《C++程序设计  基础、编程抽象与算法策略》</p>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>cplusplus<br><a href="https://cplusplus.com/reference/string/">https://cplusplus.com/reference/string/</a></p>
<p>斯坦福库<br><a href="https://web.stanford.edu/dept/cs_edu/resources/cslib_docs/">https://web.stanford.edu/dept/cs_edu/resources/cslib_docs/</a></p>
<p><a href="https://pythontutor.com/visualize.html#mode=edit">https://pythontutor.com/visualize.html#mode=edit</a></p>
<p>常见排序算法比较<br><a href="https://www.toptal.com/developers/sorting-algorithms">https://www.toptal.com/developers/sorting-algorithms</a></p>
<p>可视化<br><a href="https://visualgo.net/">https://visualgo.net/</a></p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Heap.html">https://www.cs.usfca.edu/~galles/visualization/Heap.html</a></p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><ol>
<li>-&gt;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">pt</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">Point *pp = &amp;pt;</span><br></pre></td></tr></table></figure>

<p>指向结构和对象的指针<br>pp-&gt;getX() 相当于 (*pp).getX()</p>
<ol start="2">
<li>关键字 this</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Point</span> (<span class="type">int</span> cx, <span class="type">int</span> cy) &#123;</span><br><span class="line">    x = cx;</span><br><span class="line">    y = cy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Point</span> (<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用相同，因为变量名不能相同，用this来实现</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>冒泡算法</p>
<p>二叉堆、二叉搜索树<br>Set的底层实现：二叉搜索树</p>
<p>引用传递</p>
<p>链表连接</p>
]]></content>
  </entry>
  <entry>
    <title>Cplusplus</title>
    <url>/2023/01/04/Cplusplus/</url>
    <content><![CDATA[<p>namespace Foam</p>
<p>namespace fv</p>
<p>&#x2F;&#x2F; Class gaussGrad Declaration</p>
<p>template</p>
<p>class</p>
<p>public</p>
<p>&#x2F;&#x2F; Private Data</p>
<p>&#x2F;&#x2F; Constructors</p>
<p>&#x2F;&#x2F;- Construct from mesh</p>
<p>&#x2F;&#x2F;- Construct from mesh and Istream</p>
<p>&#x2F;&#x2F; Member Functions</p>
<p>#ifndef gaussGrad_H<br>#define gaussGrad_H</p>
<p>#ifdef NoRepository<br>    #include “gaussGrad.C”<br>#endif</p>
<p>&lt;</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>&amp;<br>引用<br>所谓引用，其实就是给变量取另外一个名字，其中两个变量任何一个发生变化，另一个随之改变。<br><a href="https://blog.csdn.net/mikedadong/article/details/50099813">https://blog.csdn.net/mikedadong/article/details/50099813</a><br><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">https://www.runoob.com/cplusplus/cpp-pointer-operators.html</a></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>冒号：<br>class 继承<br><a href="https://blog.csdn.net/f2006116/article/details/89057348">https://blog.csdn.net/f2006116/article/details/89057348</a></p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>namespace<br>::<br> <a href="https://cplusplus.com/doc/oldtutorial/namespaces/">https://cplusplus.com/doc/oldtutorial/namespaces/</a><br> <a href="https://www.runoob.com/cplusplus/cpp-namespaces.html">https://www.runoob.com/cplusplus/cpp-namespaces.html</a></p>
<h3 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h3><h4 id="ifndef-tmp-H"><a href="#ifndef-tmp-H" class="headerlink" title="#ifndef tmp_H"></a>#ifndef tmp_H</h4><p>#define tmp_H</p>
<h4 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h4><p>typedef GeometricField&lt;scalar, fvPatchField, volMesh&gt; volScalarField;</p>
<h4 id="this"><a href="#this" class="headerlink" title="*this"></a>*this</h4><h4 id="gt"><a href="#gt" class="headerlink" title="-&gt;"></a>-&gt;</h4><p>src&#x2F;transportModels&#x2F;interfaceProperties&#x2F;interfaceProperties.C</p>
<p>Foam::tmp<a href="Foam::volScalarField">Foam::volScalarField</a><br>Foam::interfaceProperties::sigmaK() const<br>{<br>    return sigmaPtr_-&gt;sigma()*K_;<br>}</p>
<p>sigmaPtr_-&gt;sigma()<br>gradAlphaf&#x2F;(mag(gradAlphaf)<br>K_ &#x3D;  -fvc::div(nHatf_);</p>
<h4 id="Disallow-default-bitwise-copy-construction"><a href="#Disallow-default-bitwise-copy-construction" class="headerlink" title="Disallow default bitwise copy construction"></a>Disallow default bitwise copy construction</h4><p>src&#x2F;transportModels&#x2F;interfaceProperties&#x2F;interfaceProperties.H</p>
<pre><code>    //- Disallow default bitwise copy construction
    interfaceProperties(const interfaceProperties&amp;) = delete;
</code></pre>
<h3 id="this-gt"><a href="#this-gt" class="headerlink" title="this-&gt;"></a>this-&gt;</h3><p><a href="https://www.runoob.com/cplusplus/cpp-this-pointer.html">https://www.runoob.com/cplusplus/cpp-this-pointer.html</a><br><a href="http://c.biancheng.net/view/2226.html">http://c.biancheng.net/view/2226.html</a></p>
<p>src&#x2F;finiteVolume&#x2F;interpolation&#x2F;surfaceInterpolation&#x2F;limitedSchemes&#x2F;upwind&#x2F;upwind.H</p>
<p>指自己</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmp&lt;surfaceScalarField&gt; weights() const</span><br><span class="line">&#123;</span><br><span class="line">    return pos0(this-&gt;faceFlux_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="template-模板"><a href="#template-模板" class="headerlink" title="template 模板"></a>template 模板</h3><p>template<class Type><br><a href="https://cplusplus.com/doc/oldtutorial/templates/">https://cplusplus.com/doc/oldtutorial/templates/</a><br><a href="https://www.runoob.com/cplusplus/cpp-templates.html">https://www.runoob.com/cplusplus/cpp-templates.html</a></p>
<p>函数模板<br>类模板</p>
]]></content>
  </entry>
  <entry>
    <title>Latex flow chart</title>
    <url>/2022/11/10/Latex-flow-chart/</url>
    <content><![CDATA[<p><img src="/2022/11/10/Latex-flow-chart/example.png" alt="案例"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>[all]&#123;genealogytree&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;tikzpicture&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\genealogytree</span>[timeflow = left,</span><br><span class="line">processing = tcolorbox,</span><br><span class="line">level size = 2.5cm, node size from = 5mm to 4cm,</span><br><span class="line">box = &#123;size=small, halign=center, valign=center, fontupper=<span class="keyword">\small</span><span class="keyword">\sffamily</span>&#125;,</span><br><span class="line">highlight/.style = &#123;pivot,box=&#123;colback=yellow!20, no shadow, fuzzy halo&#125;&#125;,</span><br><span class="line">]&#123;</span><br><span class="line">parent&#123;</span><br><span class="line">    g&#123;A&#125;</span><br><span class="line">    p&#123;1&#125;</span><br><span class="line">    p&#123;2&#125;</span><br><span class="line">    p&#123;3&#125;</span><br><span class="line">    p&#123;4&#125;</span><br><span class="line">    p&#123;5&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;tikzpicture&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>参考教程</p>
<p><a href="https://www.jianshu.com/p/2d01d5eaaa77">https://www.jianshu.com/p/2d01d5eaaa77</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/82435856">https://zhuanlan.zhihu.com/p/82435856</a></p>
<p><a href="https://mdnice.com/user/737263163320">https://mdnice.com/user/737263163320</a></p>
<p><a href="https://scaomath.github.io/blog/short-tikz-tutorial/">https://scaomath.github.io/blog/short-tikz-tutorial/</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2023/01/13/Linux/</url>
    <content><![CDATA[<p><a href="https://www.runoob.com/linux/linux-comm-tar.html">https://www.runoob.com/linux/linux-comm-tar.html</a></p>
<h3 id="文件-x2F-文件夹"><a href="#文件-x2F-文件夹" class="headerlink" title="文件&#x2F;文件夹"></a>文件&#x2F;文件夹</h3><p>新建文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir A</span><br></pre></td></tr></table></figure>
<p>新建文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch A</span><br></pre></td></tr></table></figure>
<p>打开文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xdg-open A</span><br></pre></td></tr></table></figure>
<p>可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x A</span><br></pre></td></tr></table></figure>
<p>修改名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv A B</span><br></pre></td></tr></table></figure>
<p>复制并重命名,(-r)代表文件夹操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r A B</span><br></pre></td></tr></table></figure>
<p>转到目标文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd A</span><br></pre></td></tr></table></figure>


<p>批量修改文件内容<br>sed -i “s&#x2F;oldString&#x2F;newString&#x2F;g”  <code>grep oldString -rl /path</code><br>在当前目录 &#x2F;path 换成 .</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><a href="https://www.runoob.com/linux/linux-comm-find.html">https://www.runoob.com/linux/linux-comm-find.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">&quot;funkySetFieldsDict&quot;</span></span><br><span class="line">find . -name <span class="string">&quot;*.m&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget file/web</span><br></pre></td></tr></table></figure>

<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf file </span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>内存、cpu使用情况<br><a href="https://blog.csdn.net/we_shell/article/details/36887629">https://blog.csdn.net/we_shell/article/details/36887629</a></p>
<p>系统监视窗口<br>gnome-system-monitor</p>
<p>转到挂载的其他硬盘<br>cd media&#x2F;</p>
]]></content>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2022/11/23/Markdown/</url>
    <content><![CDATA[<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>引用区</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">&lt;sup&gt;1&lt;/sup&gt;</span>](<span class="link">#1</span>)</span><br></pre></td></tr></table></figure>

<p>参考区</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [<span class="string">1</span>] [<span class="string">谷歌学术</span>](<span class="link">https://scholar.google.com/</span>)</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><a href="#1"><sup>1</sup></a></p>
<div id="1"></div>

<ul>
<li>[1] <a href="https://scholar.google.com/">谷歌学术</a></li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>表示方法一  </p>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<p>表示方法二  </p>
<pre><code><figure class="highlight plaintext"><figcaption><span>c_cpp_properties.json</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<p>效果：</p>
<p>表示方法三  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```C++</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#96;&#96;&#96;<br>空四格</p>
<h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h3><p><a href="https://www.jianshu.com/p/1d23742be73c">https://www.jianshu.com/p/1d23742be73c</a></p>
]]></content>
  </entry>
  <entry>
    <title>Math</title>
    <url>/2023/01/07/Math/</url>
    <content><![CDATA[<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>Chapter 11 偏微分方程<br><a href="https://bookdown.org/yifei/book/">https://bookdown.org/yifei/book/</a><br><a href="https://bookdown.org/yifei/book/pde.html">https://bookdown.org/yifei/book/pde.html</a></p>
<p><a href="https://www.shud.xyz/book_nme/modeling.html">https://www.shud.xyz/book_nme/modeling.html</a></p>
<h3 id="离散"><a href="#离散" class="headerlink" title="离散"></a>离散</h3><p><a href="https://zhuanlan.zhihu.com/p/149680131">https://zhuanlan.zhihu.com/p/149680131</a></p>
<h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><p>第五章 Laplace方程<br><a href="http://www.cms.zju.edu.cn/UploadFiles/AttachFiles/20081230224356870.pdf">http://www.cms.zju.edu.cn/UploadFiles/AttachFiles/20081230224356870.pdf</a></p>
<p><a href="http://www.cms.zju.edu.cn/">http://www.cms.zju.edu.cn/</a><br>方程 site::<a href="http://www.cms.zju.edu.cn/">http://www.cms.zju.edu.cn/</a></p>
<p><a href="https://ppwq.net/">https://ppwq.net/</a><br>偏微分方程 浙江大学</p>
<p>Courant-Friedrichs-Lewy 准则\</p>
<p>最优化<br><a href="https://www.zhihu.com/question/24791334">https://www.zhihu.com/question/24791334</a><br>Convex Optimization<br><a href="http://faculty.bicmr.pku.edu.cn/~wenzw/optbook.html">http://faculty.bicmr.pku.edu.cn/~wenzw/optbook.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM Debug</title>
    <url>/2022/12/01/OpenFOAM-Debug/</url>
    <content><![CDATA[<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>安装MinGW</p>
<p>环境变量加入<br>D:\MinGW\bin</p>
<p>终端输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>
<p>有输出就是部署成功</p>
<p>Visual Studio Code 如何编写运行 C、C++ 程序</p>
<h3 id="Vscode-远程代码跳转"><a href="#Vscode-远程代码跳转" class="headerlink" title="Vscode 远程代码跳转"></a>Vscode 远程代码跳转</h3><p>安装C++插件</p>
<p><img src="/C++.png.png" alt="C++插件"></p>
<p>用VS Code开发时，有三个配置文件，分别是tasks.json, launch.json 和 c_cpp_properties.json</p>
<p>c_cpp_properties.json 文件配置系统环境</p>
<p>手动条件 .vscode 文件</p>
<p>自动配置<br>Ctrl + Shift + P Command Palette,运行C&#x2F;Cpp: Edit configurations…生成c_cpp_properties.json：</p>
<p>复制粘贴</p>
<h4 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h4><p>c_cpp_properties.json 主要包含头文件（依赖文件）路径，设置C++版本号等。</p>
<figure class="highlight plaintext"><figcaption><span>c_cpp_properties.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;Linux&quot;,                // 配置名称，默认为系统名，可更改</span><br><span class="line">            &quot;includePath&quot;: [                // 运行项目中包含.h头文件的目录</span><br><span class="line">                &quot;$&#123;workspaceFolder&#125;/**&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;defines&quot;: [],                  // 定义变量</span><br><span class="line">            &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, // 编译器路径</span><br><span class="line">            &quot;cStandard&quot;: &quot;gnu17&quot;,           // C标准的版本</span><br><span class="line">            &quot;cppStandard&quot;: &quot;gnu++14&quot;,       // C++标准的版本</span><br><span class="line">            &quot;intelliSenseMode&quot;: &quot;linux-gcc-x64&quot;     // 默认</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>${workspaceFolder}&#x2F; 替换为安装的OpenFOAM源文件路径即可，例如&#x2F;home&#x2F;jian&#x2F;OpenFOAM&#x2F;OpenFOAM-7&#x2F;**<br>注意要保留**<br>或者 &#x2F;home&#x2F;jian&#x2F;OpenFOAM&#x2F;OpenFOAM-7  </p>
<p>可以实现代码跳转功能。</p>
<h4 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h4><figure class="highlight plaintext"><figcaption><span>launch.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;solver&quot;,           // 运行和调试任务的名称，可自定义</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,           // 配置类型，默认</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,        // launch模式允许打断点进行调试，默认</span><br><span class="line">            &quot;program&quot;: &quot;&quot;,              // 运行程序目录</span><br><span class="line">            &quot;args&quot;: [],                 // 程序的其他参数</span><br><span class="line">            &quot;stopAtEntry&quot;: true,        // 在入口暂停，true相当于入口增加断点</span><br><span class="line">            &quot;cwd&quot;: &quot;&quot;,                  // 运行路径</span><br><span class="line">            &quot;environment&quot;: [],          // 环境变量</span><br><span class="line">            &quot;externalConsole&quot;: false,   // 外部控制台，true时开启系统控制台窗口</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,            // gdb调试</span><br><span class="line">            &quot;setupCommands&quot;: [          // 设置gdb调试的参数，默认</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                 &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;ofextension: debug solver&quot;,       // 运行和调试前执行的任务，一般为编译程序，任务名要和tasks.json的label对应</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;        // debug调试工具的路径</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>program是编译后求解器的路径<br>例如：&#x2F;home&#x2F;jian&#x2F;OpenFOAM&#x2F;najian-7&#x2F;platforms&#x2F;linux64GccDPInt32Opt&#x2F;bin&#x2F;interFoam</p>
<p>args是命令行参数，例如执行reconstructPar -time 10<br>“args”: [“-time” “10”],</p>
<p>cwd是case的目录<br>例如：&#x2F;home&#x2F;jian&#x2F;OpenFOAM&#x2F;najian-7&#x2F;run&#x2F;case&#x2F;interFoam&#x2F;interFoamcase<br>也可以用 ${workspaceFolder} 表示当前文件夹</p>
<h4 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h4><figure class="highlight plaintext"><figcaption><span>tasks.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;ofextension: build solver&quot;,       // 任务名，与launch.json的&quot;preLaunchTask&quot;对应</span><br><span class="line">            &quot;command&quot;: [        // 要使用的编译器</span><br><span class="line">                &quot;cd $&#123;workspaceFolder&#125;;&quot;,</span><br><span class="line">                &quot;source /home/najian/OpenFOAM-7/etc/bashrc WM_NCOMPROCS=2;&quot;,</span><br><span class="line">                &quot;wmake 2&gt;&amp;1 | tee log.wmake_opt&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在options</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -g \</span><br><span class="line">    -I$(LIB_SRC)/transportModels/twoPhaseMixture/lnInclude \</span><br></pre></td></tr></table></figure>


<p><a href="https://www.zhihu.com/question/30315894/answer/154979413">https://www.zhihu.com/question/30315894/answer/154979413</a></p>
<p><a href="https://blog.csdn.net/baidu_38634017/article/details/99875321">https://blog.csdn.net/baidu_38634017/article/details/99875321</a></p>
<p><a href="https://www.cnblogs.com/harrypotterisdead/p/14207866.html">https://www.cnblogs.com/harrypotterisdead/p/14207866.html</a></p>
<p>VS Code 远程调试 OpenFOAM<br><a href="https://openfoam.top/vscodeDebug/">https://openfoam.top/vscodeDebug/</a></p>
<p>利用VS Code阅读源码及调试OpenFOAM<br><a href="http://www.xfy-learning.com/2021/01/05/%E5%88%A9%E7%94%A8VS-Code%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E5%8F%8A%E8%B0%83%E8%AF%95OpenFOAM/">http://www.xfy-learning.com/2021/01/05/%E5%88%A9%E7%94%A8VS-Code%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E5%8F%8A%E8%B0%83%E8%AF%95OpenFOAM/</a></p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM IOobject</title>
    <url>/2023/01/04/OpenFOAM-IOobject/</url>
    <content><![CDATA[<p><a href="https://www.openfoam.com/documentation/guides/latest/api/classFoam_1_1IOobject.html">https://www.openfoam.com/documentation/guides/latest/api/classFoam_1_1IOobject.html</a></p>
<p><a href="https://cpp.openfoam.org/v10/classFoam_1_1IOobject.html">https://cpp.openfoam.org/v10/classFoam_1_1IOobject.html</a></p>
<p>IOobject (const word &amp;name, const fileName &amp;instance, const objectRegistry &amp;registry, readOption r&#x3D;NO_READ, writeOption w&#x3D;NO_WRITE, bool registerObject&#x3D;true)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">GeometricField</span>&lt;GradType, fvPatchField, volMesh&gt;</span><br><span class="line">(</span><br><span class="line">    <span class="built_in">IOobject</span></span><br><span class="line">    (</span><br><span class="line">        name,</span><br><span class="line">        ssf.<span class="built_in">instance</span>(), <span class="comment">// instance</span></span><br><span class="line">        mesh,</span><br><span class="line">        IOobject::NO_READ,</span><br><span class="line">        IOobject::NO_WRITE</span><br><span class="line">    ),</span><br><span class="line">    mesh,</span><br><span class="line">    <span class="built_in">dimensioned</span>&lt;GradType&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        ssf.<span class="built_in">dimensions</span>()/dimLength,</span><br><span class="line">        Zero</span><br><span class="line">    ),</span><br><span class="line">    extrapolatedCalculatedFvPatchField&lt;GradType&gt;::typeName</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">volScalarField <span class="title">p</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;p&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        runTime.timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::NO_READ,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::AUTO_WRITE</span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    p_rgh + rho*gh</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>OpenFOAM assignment</title>
    <url>/2023/01/06/OpenFOAM-assignment/</url>
    <content><![CDATA[<p>赋值</p>
<h3 id="括号赋值"><a href="#括号赋值" class="headerlink" title="括号赋值"></a>括号赋值</h3><p>src&#x2F;transportModels&#x2F;interfaceProperties&#x2F;interfaceProperties.C</p>
<pre><code>// Cell gradient of alpha
const volVectorField gradAlpha(fvc::grad(alpha1_, &quot;nHat&quot;));

// Interpolated face-gradient of alpha
surfaceVectorField gradAlphaf(fvc::interpolate(gradAlpha));
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM Matrix</title>
    <url>/2023/01/07/OpenFOAM-Matrix/</url>
    <content><![CDATA[<p>矩阵，对流扩散方程</p>
<p><a href="https://q8frym1nsp.feishu.cn/docx/FIg5dgAk0oD0o9xo8bpc9knonUf">https://q8frym1nsp.feishu.cn/docx/FIg5dgAk0oD0o9xo8bpc9knonUf</a></p>
<p>对角，</p>
<p>上下三角</p>
<p>Li 7.5<br>例如时间项离散就没有非对角阵元素，扩散项离散则有非对角阵<br>元素）。具体的项的离散后的非对角阵元素位置，由网格直接确定</p>
<h3 id="没看"><a href="#没看" class="headerlink" title="没看"></a>没看</h3><p>OpenFOAM的fvVectorMatrix——ldu矩阵学习（一）<br><a href="https://blog.csdn.net/weixin_39124457/article/details/123879051">https://blog.csdn.net/weixin_39124457/article/details/123879051</a></p>
<p>翻译】OpenFOAM中的空间离散化与矩阵系数<br><a href="https://zhuanlan.zhihu.com/p/32940120">https://zhuanlan.zhihu.com/p/32940120</a></p>
<p><img src="/2023/01/07/OpenFOAM-Matrix/Matrix.png" alt="fi"></p>
<p>Eqn.solve()</p>
<p>&#x3D; fvOptions(T) S </p>
<p>&#x2F;home&#x2F;shuoxing&#x2F;OpenFOAM&#x2F;OpenFOAM-7&#x2F;src&#x2F;OpenFOAM&#x2F;matrices&#x2F;lduMatrix&#x2F;lduMatrix&#x2F;lduMatrix.C</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lower()</span><br><span class="line">diag()</span><br><span class="line">upper()</span><br></pre></td></tr></table></figure>

<p>lduAddressing<br>The Finite Volume Method in Computational Fluid Dynamics: An Advanced Introduction with OpenFOAM® and Matlab 7.2.4</p>
<p><a href="https://blog.csdn.net/weixin_42849849/article/details/125425068">https://blog.csdn.net/weixin_42849849/article/details/125425068</a></p>
<p>OpenFOAM矩阵组装的系统介绍(全)<br><a href="https://zhuanlan.zhihu.com/p/366736087">https://zhuanlan.zhihu.com/p/366736087</a></p>
<h3 id="矩阵建立"><a href="#矩阵建立" class="headerlink" title="矩阵建立"></a>矩阵建立</h3><p>src&#x2F;finiteVolume&#x2F;finiteVolume&#x2F;convectionSchemes&#x2F;gaussConvectionScheme&#x2F;gaussConvectionScheme.C</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fvm.lower() = -weights.primitiveField()*faceFlux.primitiveField();</span><br><span class="line">fvm.upper() = fvm.lower() + faceFlux.primitiveField();</span><br></pre></td></tr></table></figure>
<p>7.5 OPENFOAM 中的稀疏线性系统求解器</p>
<h3 id="矩阵求解"><a href="#矩阵求解" class="headerlink" title="矩阵求解"></a>矩阵求解</h3><p>src&#x2F;OpenFOAM&#x2F;lnInclude&#x2F;GaussSeidelSmoother.C<br>Foam::GaussSeidelSmoother</p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM fvSchemes</title>
    <url>/2023/01/14/OpenFOAM-fvSchemes/</url>
    <content><![CDATA[<p><a href="https://cpp.openfoam.org/v10/">https://cpp.openfoam.org/v10/</a></p>
<p><a href="https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-divergence.html">https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-divergence.html</a></p>
<p><a href="https://www.openfoam.com/documentation/guides/v2112/doc/guide-schemes-divergence-example.html">https://www.openfoam.com/documentation/guides/v2112/doc/guide-schemes-divergence-example.html</a></p>
<p><a href="https://doc.cfd.direct/openfoam/user-guide-v10/fvschemes">https://doc.cfd.direct/openfoam/user-guide-v10/fvschemes</a></p>
<p><a href="https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-divergence-deshybrid.html">https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-divergence-deshybrid.html</a></p>
<p>divSchemes</p>
<h3 id="离散格式的性能的对比"><a href="#离散格式的性能的对比" class="headerlink" title="离散格式的性能的对比"></a>离散格式的性能的对比</h3><h4 id="中心差分"><a href="#中心差分" class="headerlink" title="中心差分"></a>中心差分</h4><h4 id="一阶迎风"><a href="#一阶迎风" class="headerlink" title="一阶迎风"></a>一阶迎风</h4><p>离散系数恒大于零，不会引起解的震荡</p>
<p>二阶迎风，三阶迎风是否稳定？<br>二阶迎风绝对稳定？仍有假扩散问题。</p>
<p>乘方格式 power-law scheme<br>混合格式<br>指数格式</p>
<p>迎风格式和混合格式只有一阶计算精度<br>中心差分格式具有二阶精度，但它的稳定性很差，也不满足输运特性。<br><a href="https://www.jishulink.com/post/267426">https://www.jishulink.com/post/267426</a><br><img src="/2023/01/14/OpenFOAM-fvSchemes/%E7%A6%BB%E6%95%A3%E6%A0%BC%E5%BC%8F%E5%AF%B9%E6%AF%94.png" alt="离散格式对比"></p>
<p>如何实现幂律或混合方案？<br><a href="https://www.cfd-online.com/Forums/openfoam-programming-development/88078-how-implement-power-law-hybrid-schemes.html">https://www.cfd-online.com/Forums/openfoam-programming-development/88078-how-implement-power-law-hybrid-schemes.html</a><br>Upwind scheme: this scheme impose artificial dispersion (false diffusion) which Leeds to unrealistic solution.<br>Linear scheme (central differencing): causes oscillating answer for high Reynolds numbers and unrealistic solution.</p>
<p>Why you should not use ‘Hybrid’, ‘Power-Law’ or related exponential schemes for convective modelling—there are much better alternatives</p>
<p><a href="https://www.cfd-online.com/Forums/main/794-power-law-scheme.html">https://www.cfd-online.com/Forums/main/794-power-law-scheme.html</a></p>
<p>【薛定谔的alpha狗<br>】有限体积法（9）——高阶差分格式：QUICK格式<br><a href="https://blog.csdn.net/weixin_42562856/article/details/107323235">https://blog.csdn.net/weixin_42562856/article/details/107323235</a></p>
<p>计算流体力学常用离散格式的对比与讨论<br><a href="http://cmfd.com.cn/index.php?s=bbs&amp;c=show&amp;id=2284">http://cmfd.com.cn/index.php?s=bbs&amp;c=show&amp;id=2284</a></p>
<p>慎用高阶格式<br><a href="https://www.cnblogs.com/Xiwang-Sun/p/16453482.html">https://www.cnblogs.com/Xiwang-Sun/p/16453482.html</a></p>
<h3 id="假扩散"><a href="#假扩散" class="headerlink" title="假扩散"></a>假扩散</h3><p>对流项的高阶迎风型格式<br><a href="http://staff.ustc.edu.cn/~humaobin/course/cht/ppt/5.5.pdf">http://staff.ustc.edu.cn/~humaobin/course/cht/ppt/5.5.pdf</a><br><a href="http://staff.ustc.edu.cn/~humaobin/course/cht/ppt/5.0.pdf">http://staff.ustc.edu.cn/~humaobin/course/cht/ppt/5.0.pdf</a></p>
<p>数值传热学 5.5 </p>
<p>一阶迎风，二阶导数项<br>扩散项是二阶导数<br>一维非稳态对流方程，采用显示、迎风，二阶截断误差，离散方程实际上是对流-扩散问题</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>高分辨率组合格式 TVD 格式</p>
<p>blended 混合格式<br><img src="/2023/01/14/OpenFOAM-fvSchemes/blended.png" alt="blended"><br><a href="https://cpp.openfoam.org/v7/classFoam_1_1blendedSchemeBase.html">https://cpp.openfoam.org/v7/classFoam_1_1blendedSchemeBase.html</a></p>
<p>blended<br>linear&#x2F;upwind blended differencing scheme.</p>
<p>Gauss CoBlended</p>
<p>LUST: Linear-upwind stabilised transport.<br>src&#x2F;finiteVolume&#x2F;interpolation&#x2F;surfaceInterpolation&#x2F;schemes&#x2F;</p>
<p>makeSurfaceInterpolationTypeScheme</p>
<p><a href="https://openfoamwiki.net/index.php/OpenFOAM_guide/SurfaceInterpolation">https://openfoamwiki.net/index.php/OpenFOAM_guide/SurfaceInterpolation</a></p>
<p><a href="https://openfoamwiki.net/index.php/OpenFOAM_guide">https://openfoamwiki.net/index.php/OpenFOAM_guide</a></p>
<p><a href="https://openfoamwiki.net/index.php/Main_Page">https://openfoamwiki.net/index.php/Main_Page</a></p>
<p><a href="https://www.zybuluo.com/daidezhi/note/389113">https://www.zybuluo.com/daidezhi/note/389113</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class Type&gt;</span><br><span class="line">class LUST</span><br><span class="line">:</span><br><span class="line">    public linearUpwind&lt;Type&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class Type&gt;</span><br><span class="line">class linearUpwind</span><br><span class="line">:</span><br><span class="line">    public upwind&lt;Type&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class Type&gt;</span><br><span class="line">class upwind</span><br><span class="line">:</span><br><span class="line">    public limitedSurfaceInterpolationScheme&lt;Type&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class Type&gt;</span><br><span class="line">class limitedSurfaceInterpolationScheme</span><br><span class="line">:</span><br><span class="line">    public surfaceInterpolationScheme&lt;Type&gt;</span><br></pre></td></tr></table></figure>

<p>src&#x2F;finiteVolume&#x2F;interpolation&#x2F;surfaceInterpolation&#x2F;schemes&#x2F;linear&#x2F;linear.H</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class Type&gt;</span><br><span class="line">class linear</span><br><span class="line">:</span><br><span class="line">    public surfaceInterpolationScheme&lt;Type&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cfd-online.com/Forums/openfoam-programming-development/236834-face-pressure-interpolation-scheme-based-linear-interpolation.html">https://www.cfd-online.com/Forums/openfoam-programming-development/236834-face-pressure-interpolation-scheme-based-linear-interpolation.html</a></p>
<p>参考tutorial<br>OFtutorial15_discretisation&#x2F;OFtutorial15.H</p>
<p>makeSurfaceInterpolationScheme</p>
<h3 id="格式汇总"><a href="#格式汇总" class="headerlink" title="格式汇总"></a>格式汇总</h3><p>对流格式基于<code>高斯积分</code>，需要从网格单元<code>体心</code>处向<code>面心</code>处插值<br><img src="/2023/01/14/OpenFOAM-fvSchemes/1Dmesh.png" alt="一维网格示意图"></p>
<p>格式为 Gauss <interpolationScheme></p>
<p>$$<br>\int_w^e\left(\frac{\partial \phi}{\partial x}\right) \mathrm{d} x&#x3D;\phi_e-\phi_w<br>$$</p>
<p>$\phi_e$ 和 $\phi_w$ 从体心获得</p>
<h3 id="div"><a href="#div" class="headerlink" title="div"></a>div</h3><p>src&#x2F;finiteVolume&#x2F;finiteVolume&#x2F;fvm&#x2F;fvmDiv.C</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">tmp&lt;fvMatrix&lt;Type&gt;&gt;</span><br><span class="line"><span class="built_in">div</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> surfaceScalarField&amp; flux,</span><br><span class="line">    <span class="type">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; vf,</span><br><span class="line">    <span class="type">const</span> word&amp; name</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fv::convectionScheme&lt;Type&gt;::<span class="built_in">New</span></span><br><span class="line">    (</span><br><span class="line">        vf.<span class="built_in">mesh</span>(),</span><br><span class="line">        flux,</span><br><span class="line">        vf.<span class="built_in">mesh</span>().<span class="built_in">divScheme</span>(name)</span><br><span class="line">    )().<span class="built_in">fvmDiv</span>(flux, vf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fv::convectionScheme()</p>
<p>src&#x2F;finiteVolume&#x2F;finiteVolume&#x2F;convectionSchemes&#x2F;convectionScheme&#x2F;convectionScheme.H</p>
<p>fvmDiv(flux, vf)<br>return cstrIter()(mesh, faceFlux, schemeData);</p>
<p>src&#x2F;finiteVolume&#x2F;finiteVolume&#x2F;convectionSchemes&#x2F;gaussConvectionScheme&#x2F;gaussConvectionScheme.H</p>
<p><a href="https://forum.cfdac.com/t/topic/611">https://forum.cfdac.com/t/topic/611</a><br><a href="https://forum.cfdac.com/tag/codeoftheweek">https://forum.cfdac.com/tag/codeoftheweek</a></p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM grad</title>
    <url>/2023/01/04/OpenFOAM-grad/</url>
    <content><![CDATA[<h3 id="梯度格式"><a href="#梯度格式" class="headerlink" title="梯度格式"></a>梯度格式</h3><p>fvc::grad(rho)<br>default Gauss linear;<br>Gauss 指定使用<code>高斯积分</code>计算梯度，这要求体心到面心的插值。具体的体心到面心的插值格式通过linear 来指定，意味着使用中心差分进行插值。<br>1500 1500 500 500<br>grad(rho) &#x3D; (1500 + 500 -2*500)&#x2F;2x<br>中心差分：grad的值在格子中心，前后两个格子差值，除以两个格子大小<br>在交界面，</p>
<p>[OpenFOAM 中的梯度计算：高斯法]<br>(<a href="https://marinecfd.xyz/post/openfoam-gradient-scheme-gauss/">https://marinecfd.xyz/post/openfoam-gradient-scheme-gauss/</a>)</p>
<p>grad</p>
<p><a href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/">http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/</a></p>
<p><a href="https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-gradient.html">https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-gradient.html</a><br><a href="https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-gradient-example.html">https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-gradient-example.html</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gradSchemes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span>         none;</span><br><span class="line">    <span class="built_in">grad</span>(p)         &lt;optional limiter&gt; &lt;gradient scheme&gt; &lt;interpolation scheme&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gradient scheme</p>
<ul>
<li>Gauss gradient scheme</li>
<li>Least-squares gradient scheme</li>
</ul>
<p>Interpolation schemes</p>
<ul>
<li>linear: cell-based linear</li>
<li>pointLinear: point-based linear</li>
<li>leastSquares: Least squares</li>
</ul>
<p>Gauss’ theorem<br>高斯定理</p>
<p>$$<br>\int_V(\nabla \cdot \mathbf{u}) d V&#x3D;\oint_S(\mathbf{n} \cdot \mathbf{u}) d S<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gradSchemes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span>         none;</span><br><span class="line">    <span class="built_in">grad</span>(U)         Gauss &lt;interpolation scheme&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标量梯度、质量梯度</p>
<p>计算梯度在体心处的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">volVectorField gradrho = fvc::<span class="built_in">grad</span>(rho);</span><br></pre></td></tr></table></figure>
<p>有限体积近似中的线性假设<br>假设场量在控制体单元内<code>线性变化</code> </p>
<p><a href="https://cpp.openfoam.org/v7/classFoam_1_1fv_1_1gaussGrad.html">https://cpp.openfoam.org/v7/classFoam_1_1fv_1_1gaussGrad.html</a></p>
<p>src&#x2F;finiteVolume&#x2F;finiteVolume&#x2F;gradSchemes&#x2F;gaussGrad&#x2F;gaussGrad.H<br>使用面插值和高斯定理的基本二阶梯度格式。</p>
<p>返回给定场的梯度&#x2F;&#x2F;在给定表面场上使用高斯定理计算<br>gradf<br>返回给定场的梯度到gradScheme::grad,进行可选缓存<br>calcGrad<br>使用patchField snGrad函数修正梯度的边界值<br>correctBoundaryConditions</p>
<p>gradf(ssf) 面的值如何从体心获得</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foam::fv::gaussGrad&lt;Type&gt;::<span class="built_in">gradf</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> GeometricField&lt;Type, fvsPatchField, surfaceMesh&gt;&amp; ssf,</span><br><span class="line">    <span class="type">const</span> word&amp; name</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> outerProduct&lt;vector, Type&gt;::type GradType;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> fvMesh&amp; mesh = ssf.<span class="built_in">mesh</span>(); <span class="comment">// 网格</span></span><br><span class="line"></span><br><span class="line">    tmp&lt;GeometricField&lt;GradType, fvPatchField, volMesh&gt;&gt; <span class="built_in">tgGrad</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">GeometricField</span>&lt;GradType, fvPatchField, volMesh&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="built_in">IOobject</span></span><br><span class="line">            (</span><br><span class="line">                name,</span><br><span class="line">                ssf.<span class="built_in">instance</span>(),  <span class="comment">// instance</span></span><br><span class="line">                mesh,</span><br><span class="line">                IOobject::NO_READ,</span><br><span class="line">                IOobject::NO_WRITE</span><br><span class="line">            ),</span><br><span class="line">            mesh,</span><br><span class="line">            <span class="built_in">dimensioned</span>&lt;GradType&gt;</span><br><span class="line">            (</span><br><span class="line">                <span class="string">&quot;0&quot;</span>,</span><br><span class="line">                ssf.<span class="built_in">dimensions</span>()/dimLength, <span class="comment">// ssf的单位除以长度 </span></span><br><span class="line">                Zero</span><br><span class="line">            ),</span><br><span class="line">            extrapolatedCalculatedFvPatchField&lt;GradType&gt;::typeName</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    GeometricField&lt;GradType, fvPatchField, volMesh&gt;&amp; gGrad = tgGrad.<span class="built_in">ref</span>(); <span class="comment">// 引用变量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> labelUList&amp; owner = mesh.<span class="built_in">owner</span>(); <span class="comment">// 内部面 labelUList</span></span><br><span class="line">    <span class="type">const</span> labelUList&amp; neighbour = mesh.<span class="built_in">neighbour</span>();</span><br><span class="line">    <span class="type">const</span> vectorField&amp; Sf = mesh.<span class="built_in">Sf</span>();</span><br><span class="line"></span><br><span class="line">    Field&lt;GradType&gt;&amp; igGrad = gGrad;</span><br><span class="line">    <span class="type">const</span> Field&lt;Type&gt;&amp; issf = ssf;</span><br><span class="line"></span><br><span class="line">    forAll(owner, facei)</span><br><span class="line">    &#123;</span><br><span class="line">        GradType Sfssf = Sf[facei]*issf[facei];</span><br><span class="line"></span><br><span class="line">        igGrad[owner[facei]] += Sfssf;</span><br><span class="line">        igGrad[neighbour[facei]] -= Sfssf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forAll(mesh.<span class="built_in">boundary</span>(), patchi) <span class="comment">// 边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> labelUList&amp; pFaceCells =</span><br><span class="line">            mesh.<span class="built_in">boundary</span>()[patchi].<span class="built_in">faceCells</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> vectorField&amp; pSf = mesh.<span class="built_in">Sf</span>().<span class="built_in">boundaryField</span>()[patchi];</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> fvsPatchField&lt;Type&gt;&amp; pssf = ssf.<span class="built_in">boundaryField</span>()[patchi];</span><br><span class="line"></span><br><span class="line">        forAll(mesh.<span class="built_in">boundary</span>()[patchi], facei)</span><br><span class="line">        &#123;</span><br><span class="line">            igGrad[pFaceCells[facei]] += pSf[facei]*pssf[facei];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    igGrad /= mesh.<span class="built_in">V</span>();</span><br><span class="line"></span><br><span class="line">    gGrad.<span class="built_in">correctBoundaryConditions</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tgGrad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foam::fv::gaussGrad&lt;Type&gt;::<span class="built_in">calcGrad</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp; vsf,</span><br><span class="line">    <span class="type">const</span> word&amp; name</span><br><span class="line">) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> outerProduct&lt;vector, Type&gt;::type GradType;</span><br><span class="line"></span><br><span class="line">    tmp&lt;GeometricField&lt;GradType, fvPatchField, volMesh&gt;&gt; <span class="built_in">tgGrad</span></span><br><span class="line">    (</span><br><span class="line">        <span class="built_in">gradf</span>(<span class="built_in">tinterpScheme_</span>().<span class="built_in">interpolate</span>(vsf), name)</span><br><span class="line">    );</span><br><span class="line">    GeometricField&lt;GradType, fvPatchField, volMesh&gt;&amp; gGrad = tgGrad.<span class="built_in">ref</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">correctBoundaryConditions</span>(vsf, gGrad);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tgGrad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>typename Foam::outerProduct&lt;Foam::vector, Type&gt;::type<br><code>Type</code></p>
<p>tinterpScheme_().interpolate(vsf)<br>tmp&lt;surfaceInterpolationScheme<Type>&gt; tinterpScheme_;</p>
<p>把volMesh变成surfaceMesh<br>将体心场插值计算面心场<br>返回具有显式校正的给定单元格字段的面插值<br>src&#x2F;finiteVolume&#x2F;interpolation&#x2F;surfaceInterpolation&#x2F;surfaceInterpolationScheme&#x2F;surfaceInterpolationScheme.H</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> tmp&lt;GeometricField&lt;Type, fvsPatchField, surfaceMesh&gt;&gt;</span><br><span class="line"><span class="built_in">interpolate</span>(<span class="type">const</span> GeometricField&lt;Type, fvPatchField, volMesh&gt;&amp;) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<p>返回具有显式校正的给定单元格字段的面插值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tmp&lt;GeometricField&lt;Type, fvsPatchField, surfaceMesh&gt;&gt; tsf</span><br><span class="line">        = <span class="built_in">interpolate</span>(vf, <span class="built_in">weights</span>(vf));</span><br></pre></td></tr></table></figure>
<p>interpolate</p>
<p>gradf 函数将面心值与面法向量相乘、求和，并除以控制体体积，得到体心梯度</p>
<p>tgGrad $\longrightarrow$ gGrad</p>
<p>tgGrad</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">igGrad /= mesh.<span class="built_in">V</span>(); <span class="comment">// 除以控制体体积</span></span><br></pre></td></tr></table></figure>
<p>Field<GradType>&amp; igGrad &#x3D; gGrad;</p>
<p>GeometricField&lt;GradType, fvPatchField, volMesh&gt;&amp; gGrad &#x3D; tgGrad.ref();<br>&amp;修改gGrad就是修改tgGrad<br>Field<GradType>&amp; igGrad &#x3D; gGrad;</p>
<p>return tgGrad;</p>
<p><code>GeometricField</code><br>GeometricField&lt;GradType, fvPatchField, volMesh&gt;</p>
<h3 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h3><p>src&#x2F;finiteVolume&#x2F;finiteVolume&#x2F;fvc&#x2F;fvcSnGrad.C<br>src&#x2F;finiteVolume&#x2F;finiteVolume&#x2F;snGradSchemes&#x2F;snGradScheme&#x2F;snGradScheme.H</p>
<h4 id="snGrad"><a href="#snGrad" class="headerlink" title="snGrad"></a>snGrad</h4><p>snGrad看官网doxygen的文件关联</p>
<h4 id="interpolate"><a href="#interpolate" class="headerlink" title="interpolate"></a>interpolate</h4><p>如何差值<br>volVectorField V</p>
<p>surfaceVectorField fvc::interpolate(V)<br>如何插值的<br>fvc::interpolate(V) V 如何反转回去</p>
<p>将体心场插值计算面心场</p>
<p>fvc::div(fvc::interpolate(V)) ？</p>
<p>reconstruct</p>
<p>surfaceScalarField nHatf &#x3D; nHatfv &amp; Sf;<br>volScalarField K &#x3D; -fvc::div(nHatf);</p>
<h4 id="div"><a href="#div" class="headerlink" title="div"></a>div</h4><p>div(surfaceScalarField)</p>
<h4 id="是否相等"><a href="#是否相等" class="headerlink" title="是否相等"></a>是否相等</h4><p>fvc::reconstruct(fvc::snGrad(alpha1)) * mesh.magSf()</p>
<p>fvc::grad(alpha1)</p>
<p><a href="https://www.cfd-online.com/Forums/openfoam-programming-development/77943-fvc-reconstruct-algorithm.html">https://www.cfd-online.com/Forums/openfoam-programming-development/77943-fvc-reconstruct-algorithm.html</a><br>7.10.5 fvc::reconstruct() 函数</p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM gravity</title>
    <url>/2023/01/02/OpenFOAM-gravity/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/CloudBird07/article/details/105102079">https://blog.csdn.net/CloudBird07/article/details/105102079</a></p>
<p>读取重力<br>#include “readGravitationalAcceleration.H”<br>#include “readhRef.H”<br>#include “gh.H”</p>
<figure class="highlight plaintext"><figcaption><span>Make/options</span></figcaption><table><tr><td class="code"><pre><span class="line">EXE_INC = \</span><br><span class="line">    -I$(LIB_SRC)/finiteVolume/lnInclude \</span><br><span class="line">    -I$(LIB_SRC)/meshTools/lnInclude</span><br><span class="line"></span><br><span class="line">EXE_LIBS = \</span><br><span class="line">    -lfiniteVolume \</span><br><span class="line">    -lmeshTools</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>src&#x2F;finiteVolume&#x2F;cfdTools&#x2F;general&#x2F;include&#x2F;readGravitationalAcceleration.H</p>
<figure class="highlight plaintext"><figcaption><span>Test-g</span></figcaption><table><tr><td class="code"><pre><span class="line">#include &quot;fvCFD.H&quot;</span><br><span class="line">#include &quot;fvMesh.H&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    #include &quot;setRootCase.H&quot;</span><br><span class="line">    #include &quot;createTime.H&quot;</span><br><span class="line">    #include &quot;createMesh.H&quot;</span><br><span class="line"></span><br><span class="line">    // readGravitationalAcceleration.H </span><br><span class="line">    Info&lt;&lt; &quot;\nReading g&quot; &lt;&lt; endl;</span><br><span class="line">    uniformDimensionedVectorField g</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            &quot;g&quot;,</span><br><span class="line">            runTime.constant(),</span><br><span class="line">            mesh,</span><br><span class="line">            IOobject::MUST_READ,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Info&lt;&lt; &quot;g&quot; &lt;&lt; endl &lt;&lt; g &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g [0 1 -2 0 0 0 0] (0 -9.81 0)</span><br></pre></td></tr></table></figure>

<p>#include “gh.H”<br>src&#x2F;finiteVolume&#x2F;cfdTools&#x2F;general&#x2F;include&#x2F;gh.H <code>ghf</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">dimensionedScalar <span class="title">ghRef</span><span class="params">(- mag(g)*hRef)</span></span>;</span><br><span class="line"><span class="function">volScalarField <span class="title">gh</span><span class="params">(<span class="string">&quot;gh&quot;</span>, (g &amp; mesh.C()) - ghRef)</span></span>;</span><br><span class="line"><span class="function">surfaceScalarField <span class="title">ghf</span><span class="params">(<span class="string">&quot;ghf&quot;</span>, (g &amp; mesh.Cf()) - ghRef)</span></span>;</span><br></pre></td></tr></table></figure>

<p>初始化后只和网格有关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mesh.<span class="built_in">changing</span>())</span><br><span class="line">...</span><br><span class="line">ghf = (g &amp; mesh.<span class="built_in">Cf</span>()) - ghRef;</span><br></pre></td></tr></table></figure>

<p>nohup Test-g &gt;log 2&gt;&amp;1</p>
<p>volScalarField gh(“gh”, (g &amp; mesh.C()) - ghRef);</p>
<p>g 是向量<br>mesh.C() 是向量<br>g &amp; mesh.C() 向量相乘</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">surfaceScalarField <span class="title">ghf</span><span class="params">(<span class="string">&quot;ghf&quot;</span>, (g &amp; mesh.Cf()) - ghRef)</span></span>;</span><br></pre></td></tr></table></figure>

<p>面心坐标和g相乘<br>ghf是surfaceScalarField</p>
<p>以下两相等效</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">volVectorField gradP = fvc::<span class="built_in">grad</span>(p)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">volVectorField resn = fvc::<span class="built_in">reconstruct</span>(fvc::<span class="built_in">snGrad</span>(p)* mesh.<span class="built_in">magSf</span>())</span><br></pre></td></tr></table></figure>

<p>值类型<br>volVectorField </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">volTensorField tgradU = fvc::<span class="built_in">grad</span>(U)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">surfaceScalarField snGradp = fvc::<span class="built_in">snGrad</span>(p);</span><br><span class="line">surfaceScalarField meshmagSf = mesh.<span class="built_in">magSf</span>();</span><br></pre></td></tr></table></figure>

<p>reconstruct 把surfaceScalarField变成volVectorField</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">volScalarField rho</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uniformDimensionedVectorField g</span><br></pre></td></tr></table></figure>

<h3 id="最初问题："><a href="#最初问题：" class="headerlink" title="最初问题："></a>最初问题：</h3><p><code>第一个问题</code><br>以下两种计算结果，是否相同</p>
<p>初始值p_rgh &#x3D; 0<br>由于<br>p &#x3D; p_rgh + rho*gh</p>
<p>合力fvc::grad(p) 减去重力 rho * g</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fvc::<span class="built_in">grad</span>(p) - rho * g</span><br></pre></td></tr></table></figure>
<p>极小数很多  (0 786465 0)<br>初始值alpha是跳跃的，所以fvc::grad(p) 在界面处计算梯度，rho * g界面处直接跳跃</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fvc::<span class="built_in">reconstruct</span>((ghf*fvc::<span class="built_in">snGrad</span>(rho) + fvc::<span class="built_in">snGrad</span>(p_rgh))* mesh.<span class="built_in">magSf</span>())</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fvc::<span class="built_in">reconstruct</span>((ghf*fvc::<span class="built_in">snGrad</span>(rho))* mesh.<span class="built_in">magSf</span>())  + fvc::<span class="built_in">grad</span>(p_rgh)</span><br></pre></td></tr></table></figure>

<p>结果中明显大量0  (0 784015 0)<br>fvc::grad(p_rgh) &#x3D; 0 全部为零。</p>
<p>拆分开一项一项看</p>
<p><code>由此衍生第二个问题</code><br>验证以下两个式子<br>fvc::grad(p) &#x3D; fvc::grad(p_rgh) + fvc::grad(rho*gh) </p>
<p>grad(<em>) 分别grad，grad(gh) &#x3D; g拆分，越掉0值<br>fvc::grad(rho</em>gh) &#x3D; gh * fvc::grad(rho) + rho * g</p>
<p>拆分中计算，判断是否相等<br>fvc::grad(gh)<br>g</p>
<p>化简<br>$$<br>\nabla (g \cdot x) &#x3D; g<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fvc::<span class="built_in">grad</span>(g &amp; mesh.<span class="built_in">C</span>()) = g </span><br></pre></td></tr></table></figure>

<p><code>比较中间变化时的计算值</code></p>
<p>合力 化简为<br>fvc::grad(p) - rho * g &#x3D; fvc::grad(p_rgh) + gh * fvc::grad(rho)<br>这个表达式和其他两个计算是否相同<br>也就是</p>
<p>推导公式是相同的<br>fvc::reconstruct((ghf<em>fvc::snGrad(rho))</em> mesh.magSf()) 和<br>gh * fvc::grad(rho)<br>计算结果是否相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">volVectorField ghfmeshrho = gh * fvc::<span class="built_in">grad</span>(rho);</span><br><span class="line">volVectorField ghfrhomesh = fvc::<span class="built_in">reconstruct</span>((ghf*fvc::<span class="built_in">snGrad</span>(rho))* mesh.<span class="built_in">magSf</span>());</span><br></pre></td></tr></table></figure>
<p>计算同样有差别</p>
<h3 id="压力和重力结论"><a href="#压力和重力结论" class="headerlink" title="压力和重力结论"></a>压力和重力结论</h3><p>面积分等于梯度<br>计算中存在误差</p>
<h3 id="梯度格式"><a href="#梯度格式" class="headerlink" title="梯度格式"></a>梯度格式</h3><p>fvc::grad(rho)<br>default Gauss linear;<br>Gauss 指定使用<code>高斯积分</code>计算梯度，这要求体心到面心的插值。具体的体心到面心的插值格式通过linear 来指定，意味着使用中心差分进行插值。<br>1500 1500 500 500<br>grad(rho) &#x3D; (1500 + 500 -2*500)&#x2F;2x<br>中心差分：grad的值在格子中心，前后两个格子差值，除以两个格子大小<br>在交界面，<br><code>从面计算？</code><br><a href="https://marinecfd.xyz/post/openfoam-gradient-scheme-gauss/">https://marinecfd.xyz/post/openfoam-gradient-scheme-gauss/</a></p>
<p>手动计算从面计算。<br>面的值从哪来？</p>
<p>grad</p>
<p>OpenFOAM grad</p>
<p><a href="http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/">http://xiaopingqiu.github.io/2015/05/17/OpenFOAMcode1/</a></p>
<p><a href="https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-gradient.html">https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-gradient.html</a><br><a href="https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-gradient-example.html">https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-gradient-example.html</a></p>
<h3 id="内部分别相乘"><a href="#内部分别相乘" class="headerlink" title="内部分别相乘"></a>内部分别相乘</h3><p>如何 volVectorField[1,3]*volVectorField[1,3] 内部分别相乘，获得volVectorField</p>
<p>叉乘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a ^ b </span><br></pre></td></tr></table></figure>
<p>结果在第三维上？</p>
<p><a href="https://zhuanlan.zhihu.com/p/150727050">https://zhuanlan.zhihu.com/p/150727050</a><br><a href="https://blog.csdn.net/weixin_36942960/article/details/120152638">https://blog.csdn.net/weixin_36942960/article/details/120152638</a></p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM laplacian</title>
    <url>/2023/01/07/OpenFOAM-laplacian/</url>
    <content><![CDATA[<p><a href="https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-laplacian.html">https://www.openfoam.com/documentation/guides/latest/doc/guide-schemes-laplacian.html</a></p>
<h3 id="带看"><a href="#带看" class="headerlink" title="带看"></a>带看</h3><p>OpenFOAM中laplacian项离散格式解码<br><a href="https://zhuanlan.zhihu.com/p/25337924">https://zhuanlan.zhihu.com/p/25337924</a><br>OpenFOAM 中的有限体积离散<br><a href="https://marinecfd.xyz/post/openfoam-finite-volume-discretization/">https://marinecfd.xyz/post/openfoam-finite-volume-discretization/</a></p>
<p>7.10.1 laplacian(ϕ) &#x3D; div(grad(ϕ))?</p>
<p>fvc :: laplacian (psi)</p>
<p>fvc :: div(fvc :: grad(psi))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">laplacianSchemes</span><br><span class="line">&#123;</span><br><span class="line">    default         none;</span><br><span class="line">    laplacian(gamma,phi) Gauss &lt;interpolation scheme&gt; &lt;snGrad scheme&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>openfoam.com&#x2F;documentation&#x2F;guides&#x2F;latest&#x2F;doc&#x2F;guide-schemes-sngrad.html</p>
<p>Surface-normal gradient schemes</p>
<p><a href="https://www.youtube.com/watch?v=JlB6y8NSI20">https://www.youtube.com/watch?v=JlB6y8NSI20</a><br><a href="https://forum.cfdac.com/t/topic/94">https://forum.cfdac.com/t/topic/94</a></p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM mesh</title>
    <url>/2023/01/04/OpenFOAM-mesh/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">fvMesh <span class="title">mesh</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        fvMesh::defaultRegion,</span></span></span><br><span class="line"><span class="params"><span class="function">        runTime.timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        runTime,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::MUST_READ</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">Info&lt;&lt; <span class="string">&quot;mesh.C()&quot;</span> &lt;&lt; endl &lt;&lt; mesh.<span class="built_in">C</span>() &lt;&lt; endl;</span><br><span class="line">Info&lt;&lt; <span class="string">&quot;mesh.V()&quot;</span> &lt;&lt; endl &lt;&lt; mesh.<span class="built_in">V</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">surfaceVectorField Cf = mesh.<span class="built_in">Cf</span>();</span><br><span class="line">Info&lt;&lt; <span class="string">&quot;Cf&quot;</span> &lt;&lt; endl &lt;&lt; Cf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vectorField Sf = mesh.<span class="built_in">Sf</span>();</span><br><span class="line">Info&lt;&lt; <span class="string">&quot;Sf&quot;</span> &lt;&lt; endl &lt;&lt; Sf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">surfaceScalarField magSf = mesh.<span class="built_in">magSf</span>();</span><br><span class="line">Info&lt;&lt; <span class="string">&quot;magSf&quot;</span> &lt;&lt; endl &lt;&lt; magSf &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://www.cfd-online.com/Forums/openfoam/95858-owner-neighbor.html">https://www.cfd-online.com/Forums/openfoam/95858-owner-neighbor.html</a></p>
<p>const labelUList&amp; owner &#x3D; mesh.owner();<br>const labelUList&amp; neighbour &#x3D; mesh.neighbour();</p>
<p>Each internal face in a mesh has an “owner” and a “neighbour” cell. These are the two cells it borders. There’s nothing special about this, and if you are talking only about geometry, we don’t need to tell them apart… but since the algorithms need consistent directions for fluxes, we must distinguish them. A positive flux goes from “owner” to “neighbour”.</p>
<p>面属于的单元格和相邻的单元格</p>
<p>mesh.owner() and mesh.neighbour() return only the internal faces’ owners and neighbours.<br>内部面的owner和neighbour</p>
<p><a href="https://openfoamwiki.net/index.php/Write_OpenFOAM_meshes">https://openfoamwiki.net/index.php/Write_OpenFOAM_meshes</a></p>
<p>renumberMesh<br>applications&#x2F;utilities&#x2F;mesh&#x2F;manipulation&#x2F;renumberMesh&#x2F;renumberMesh.C<br><a href="https://github.com/smenon">https://github.com/smenon</a></p>
<p><a href="https://zhulianhua.github.io/2016/10/06/of-fvMesh/">https://zhulianhua.github.io/2016/10/06/of-fvMesh/</a></p>
<p><img src="/2023/01/04/OpenFOAM-mesh/fvMesh.png" alt="fvMesh"></p>
<p>openfoam寻找与某一边界相邻的一层网格<br><a href="https://blog.csdn.net/zhaopeng162/article/details/100572546">https://blog.csdn.net/zhaopeng162/article/details/100572546</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const polyPatch&amp; cPatch = mesh.boundaryMesh()[patchID];</span><br></pre></td></tr></table></figure>
<p>OpenFOAM grad</p>
<pre><code>const labelUList&amp; owner = mesh.owner(); // 内部面 labelUList
const labelUList&amp; neighbour = mesh.neighbour();
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM namespaces</title>
    <url>/2023/01/05/OpenFOAM-namespaces/</url>
    <content><![CDATA[<p>src&#x2F;transportModels&#x2F;interfaceProperties&#x2F;interfaceProperties.C</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::surfaceScalarField&gt;</span><br><span class="line">Foam::interfaceProperties::surfaceTensionForce() const</span><br><span class="line">&#123;</span><br><span class="line">    return fvc::interpolate(sigmaK())*fvc::snGrad(alpha1_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Foam</p>
<p>fvc</p>
<p>fvm</p>
<p>fvc::div<br>fvm::div</p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM newBC</title>
    <url>/2022/12/30/OpenFOAM-newBC/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">foamNewBC -<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: foamNewBC [OPTIONS] &lt;base&gt; &lt;<span class="built_in">type</span>&gt; &lt;boundaryConditionName&gt;</span><br><span class="line">options:</span><br><span class="line">  -<span class="built_in">help</span>  | -h         <span class="built_in">print</span> the usage</span><br><span class="line"></span><br><span class="line">Create directory of <span class="built_in">source</span> and compilation files <span class="keyword">for</span> a new boundary condition</span><br><span class="line">  &lt;boundaryConditionName&gt; (<span class="built_in">dir</span>)</span><br><span class="line">  - .C and .H <span class="built_in">source</span> files</span><br><span class="line">  - Make (<span class="built_in">dir</span>)</span><br><span class="line">    - files</span><br><span class="line">    - options</span><br><span class="line">  Compiles a library named lib&lt;boundaryConditionName&gt;.so <span class="keyword">in</span> <span class="variable">$FOAM_USER_LIBBIN</span>:</span><br><span class="line">  /home/shuoxing/OpenFOAM/shuoxing-7/platforms/linux64GccDPInt32Opt/lib</span><br><span class="line"></span><br><span class="line">&lt;base&gt; conditions:</span><br><span class="line">-f | -fixedValue    | fixedValue</span><br><span class="line">-m | -mixed         | mixed</span><br><span class="line"></span><br><span class="line">&lt;<span class="built_in">type</span>&gt; options:</span><br><span class="line">-a | -all    | all  | template (creates a template class)</span><br><span class="line">-s | -scalar | scalar</span><br><span class="line">-v | -vector | vector</span><br><span class="line">-t | -tensor | tensor</span><br><span class="line">-symmTensor  | symmTensor</span><br><span class="line">-sphericalTensor | sphericalTensor</span><br></pre></td></tr></table></figure>


<p><a href="https://openfoamwiki.net/index.php/Contrib_groovyBC">https://openfoamwiki.net/index.php/Contrib_groovyBC</a></p>
<h4 id="parabolicVelocity"><a href="#parabolicVelocity" class="headerlink" title="parabolicVelocity"></a>parabolicVelocity</h4><p>文档<br>Implement Parabolic Velocity Fixed Value Boundary Condition</p>
<p>成员函数<br>遍历所有的构造函数，初始化成员数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- Peak velocity magnitude</span></span><br><span class="line">scalar maxValue_;</span><br><span class="line"><span class="comment">//- Flow direction</span></span><br><span class="line">vector n_;</span><br><span class="line"><span class="comment">//- Direction of the y-coordinate</span></span><br><span class="line">vector y_;</span><br></pre></td></tr></table></figure>

<p>constructor 构造函数</p>
<p>第一个构造函数中给定默认值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fixedValueFvPatchVectorField</span>(p, iF),</span><br><span class="line"><span class="built_in">maxValue_</span>(<span class="number">0</span>),</span><br><span class="line"><span class="built_in">n_</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="built_in">y_</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>第一个构造函数从dict中读取值，在时间目录中的字典文件中设置边界条件时，将使用此类构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fixedValueFvPatchVectorField</span>(p, iF),</span><br><span class="line"><span class="built_in">maxValue_</span>(<span class="built_in">readScalar</span>(dict.<span class="built_in">lookup</span>(<span class="string">&quot;maxValue&quot;</span>))),</span><br><span class="line"><span class="built_in">n_</span>(dict.<span class="built_in">lookup</span>(<span class="string">&quot;n&quot;</span>)),</span><br><span class="line"><span class="built_in">y_</span>(dict.<span class="built_in">lookup</span>(<span class="string">&quot;y&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>确保设定正确，归一化操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">mag</span>(n_) &lt; SMALL || <span class="built_in">mag</span>(y_) &lt; SMALL)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">FatalErrorIn</span>(<span class="string">&quot;...FvPatchVectorField(dict)&quot;</span>)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;n or y given with zero size not correct&quot;</span></span><br><span class="line">        &lt;&lt; <span class="built_in">abort</span>(FatalError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n_ /= <span class="built_in">mag</span>(n_);</span><br><span class="line">y_ /= <span class="built_in">mag</span>(y_);</span><br><span class="line"></span><br><span class="line"><span class="built_in">evaluate</span>();</span><br></pre></td></tr></table></figure>

<p>未解决<br>Construct by mapping given fixedValueTypeFvPatchField onto a new patch<br>第三个构造函数 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fixedValueFvPatchVectorField</span>(ptf, p, iF, mapper),</span><br><span class="line"><span class="built_in">maxValue_</span>(ptf.maxValue_),</span><br><span class="line"><span class="built_in">n_</span>(ptf.n_),</span><br><span class="line"><span class="built_in">y_</span>(ptf.y_)</span><br></pre></td></tr></table></figure>

<p>Copy constructor<br>第四个构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fixedValueFvPatchVectorField</span>(ptf),</span><br><span class="line"><span class="built_in">maxValue_</span>(ptf.maxValue_),</span><br><span class="line"><span class="built_in">n_</span>(ptf.n_),</span><br><span class="line"><span class="built_in">y_</span>(ptf.y_)</span><br></pre></td></tr></table></figure>

<p>Copy constructor setting internal field reference<br>第五个构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fixedValueFvPatchVectorField</span>(ptf, iF),</span><br><span class="line"><span class="built_in">maxValue_</span>(ptf.maxValue_),</span><br><span class="line"><span class="built_in">n_</span>(ptf.n_),</span><br><span class="line"><span class="built_in">y_</span>(ptf.y_)</span><br></pre></td></tr></table></figure>


<p>updateCoeffs()<br>确定patch范围boundBox，检查patch中心ctr，识别patch的面中心c，计算标量</p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM others</title>
    <url>/2023/01/16/OpenFOAM-others/</url>
    <content><![CDATA[<p>一些OpenFOAM自带的有用小工具<br><a href="https://blog.csdn.net/CloudBird07/article/details/105325409">https://blog.csdn.net/CloudBird07/article/details/105325409</a></p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM study</title>
    <url>/2023/01/20/OpenFOAM-study/</url>
    <content><![CDATA[<p><a href="https://www.cfd-china.com/topic/580/openfoam%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%E5%BB%BA%E8%AE%AE-2020%E5%B9%B4%E6%9B%B4%E6%96%B0%E7%89%88?_=1674190176266&amp;lang=zh-CN">https://www.cfd-china.com/topic/580/openfoam%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%E5%BB%BA%E8%AE%AE-2020%E5%B9%B4%E6%9B%B4%E6%96%B0%E7%89%88?_=1674190176266&amp;lang=zh-CN</a></p>
<p><img src="/2023/01/20/OpenFOAM-study/head.png" alt="头文件"></p>
<p><a href="https://forum.cfdac.com/tag/codeoftheweek">https://forum.cfdac.com/tag/codeoftheweek</a></p>
<p>数值传热学</p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM phi</title>
    <url>/2023/01/04/OpenFOAM-phi/</url>
    <content><![CDATA[<p><a href="https://www.cfd-online.com/Forums/openfoam-solving/175391-what-does-fvc-interpolate-u-mesh-sf-stand.html">https://www.cfd-online.com/Forums/openfoam-solving/175391-what-does-fvc-interpolate-u-mesh-sf-stand.html</a></p>
<p><a href="https://www.cfd-china.com/topic/4566/%E6%9E%84%E9%80%A0%E9%80%9A%E9%87%8F-phi-%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">https://www.cfd-china.com/topic/4566/%E6%9E%84%E9%80%A0%E9%80%9A%E9%87%8F-phi-%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB</a></p>
<p>通量</p>
<p>单元格之间面上的值，一个单元格到另一个单元格的流量</p>
<p>可以采用不同的方法计算通量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">surfaceScalarField <span class="title">phi</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;phi&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        runTime.timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::NO_READ,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::AUTO_WRITE</span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    fvc::flux(U)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">surfaceScalarField <span class="title">phi</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;phi&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        runTime.timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::NO_READ,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::AUTO_WRITE</span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">    dimensionedScalar(dimArea*dimVelocity, <span class="number">0</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// applications/solvers/incompressible/adjointShapeOptimizationFoam/createPhia.H</span></span><br><span class="line"><span class="function">surfaceScalarField <span class="title">phia</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;phia&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        runTime.timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::READ_IF_PRESENT,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::AUTO_WRITE</span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    linearInterpolate(Ua) &amp; mesh.Sf()</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">surfaceScalarField <span class="title">phi</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;phi&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        runTime.timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::NO_READ,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::NO_WRITE</span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">    dimensionedScalar(mesh.Sf().dimensions()*U.dimensions(), <span class="number">0</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>interpolate(U) 给patch补丁上的速度。 surfaceScalarField mesh.Sf() 是表面向量（面的面积和法线）。&amp; 是标量积。 因此，u 和表面矢量的标量积就是通量。</p>
<p>fvc::flux(U)可以指定格式<br>linearInterpolate(U) &amp; mesh.Sf()已经指定格式</p>
]]></content>
  </entry>
  <entry>
    <title>OpenFOAM surfaceTension</title>
    <url>/2023/01/05/OpenFOAM-surfaceTension/</url>
    <content><![CDATA[<p>表面张力是面力，不是体积力<br><a href="https://www.cfd-online.com/Forums/openfoam-solving/60581-surface-tension-force.html">https://www.cfd-online.com/Forums/openfoam-solving/60581-surface-tension-force.html</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">immiscibleIncompressibleTwoPhaseMixture <span class="title">mixture</span><span class="params">(U, phi)</span></span>;</span><br><span class="line"></span><br><span class="line">fvc::<span class="built_in">reconstruct</span>((mixture.<span class="built_in">surfaceTensionForce</span>()) * mesh.<span class="built_in">magSf</span>())</span><br></pre></td></tr></table></figure>

<p>src&#x2F;transportModels&#x2F;immiscibleIncompressibleTwoPhaseMixture&#x2F;immiscibleIncompressibleTwoPhaseMixture.H</p>
<p>类<br>Class<br>Foam::immiscibleIncompressibleTwoPhaseMixture</p>
<p>An immiscible incompressible two-phase mixture transport model</p>
<p>Constructors<br>构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">immiscibleIncompressibleTwoPhaseMixture</span></span><br><span class="line">:</span><br><span class="line">    <span class="keyword">public</span> incompressibleTwoPhaseMixture,</span><br><span class="line">    <span class="keyword">public</span> interfaceProperties</span><br><span class="line">&#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>immiscibleIncompressibleTwoPhaseMixture.C</span></figcaption><table><tr><td class="code"><pre><span class="line">Foam::immiscibleIncompressibleTwoPhaseMixture::</span><br><span class="line">immiscibleIncompressibleTwoPhaseMixture</span><br><span class="line">(</span><br><span class="line">    const volVectorField&amp; U,</span><br><span class="line">    const surfaceScalarField&amp; phi</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    incompressibleTwoPhaseMixture(U, phi),</span><br><span class="line">    interfaceProperties(alpha1(), U, *this)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>执行<br>incompressibleTwoPhaseMixture(U, phi),<br>interfaceProperties(alpha1(), U, *this)</p>
<p>mixture可以访问incompressibleTwoPhaseMixture 和 interfaceProperties</p>
<p>mixture.surfaceTensionForce()</p>
<p>修正动态接触角的 alpha 边界条件。<br>计算界面曲率</p>
<p>src&#x2F;transportModels&#x2F;interfaceProperties&#x2F;interfaceProperties.C</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::surfaceScalarField&gt;</span><br><span class="line">Foam::interfaceProperties::surfaceTensionForce() const</span><br><span class="line">&#123;</span><br><span class="line">    return fvc::interpolate(sigmaK())*fvc::snGrad(alpha1_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构：classTest2 class namespaces</p>
<p>fvc::interpolate(sigmaK()) * fvc::snGrad(alpha1_)<br>没有除去模？<br>计算面</p>
<p>interpolate() 给patch补丁上的向量。体心向量变成面<br>把volMesh变成surfaceMesh<br>将体心场插值计算面心场<br>返回具有显式校正的给定单元格字段的面插值</p>
<p>sigma()*K_</p>
<p>volScalarField K_;</p>
<p>构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foam::interfaceProperties::<span class="built_in">interfaceProperties</span>(<span class="comment">/*...*/</span>)</span><br><span class="line">: <span class="comment">/*...*/</span></span><br><span class="line">&#123;<span class="built_in">calculateK</span>()&#125;</span><br></pre></td></tr></table></figure>

<p>calculateK()<br>Re-calculate the interface curvature</p>
<p><a href="https://www.cfd-online.com/Forums/openfoam-programming-development/159243-plotting-surface-tension-force-interfoam.html">https://www.cfd-online.com/Forums/openfoam-programming-development/159243-plotting-surface-tension-force-interfoam.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>PDE</title>
    <url>/2023/01/24/PDE/</url>
    <content><![CDATA[<p>偏微分方程 浙江大学</p>
<p>Courant-Friedrichs-Lewy 准则</p>
]]></content>
  </entry>
  <entry>
    <title>SIMPLE</title>
    <url>/2023/02/03/SIMPLE/</url>
    <content><![CDATA[<p>An introduction to computational fluid dynamics: the finite volume method<br>Chapter six</p>
<p><img src="/2023/02/03/SIMPLE/staggered_grid.png" alt="staggered grid"></p>
<p><a href="https://zhuanlan.zhihu.com/p/390914441">https://zhuanlan.zhihu.com/p/390914441</a><br><a href="https://zhuanlan.zhihu.com/p/390914441">https://zhuanlan.zhihu.com/p/390914441</a></p>
<p>Numerical methods for partial differential equations: finite difference and finite volume methods</p>
<p>计算流程</p>
<p>边界条件</p>
<p>出口未知</p>
<p>滑移壁面边界条件：<br>壁面<code>法向速度</code>为零，<code>切向速度</code>可以用场内值做单边插值得到</p>
<p>无滑移壁面边界条件：<br>流固边界处速度<code>法向分量</code>和<code>切向分量</code>均为零</p>
<p><a href="https://www.cfd-china.com/topic/3945/">https://www.cfd-china.com/topic/3945/</a></p>
<p><a href="https://www.cfd-china.com/topic/948/">https://www.cfd-china.com/topic/948/</a></p>
<p><img src="/2023/02/03/SIMPLE/Momentum.png" alt="动量方程数量级分析"></p>
<p>参考书目<br>数值传热学<br>An introduction to computational fluid dynamics: the finite volume method<br>Sandip 《Numerical methods for partial differential equations: finite difference and finite volume methods》<br>Sandip 教学视频<br>Patanker 《numerical heat transfer and fluid flow》</p>
]]></content>
  </entry>
  <entry>
    <title>adjoint</title>
    <url>/2023/01/01/adjoint/</url>
    <content><![CDATA[<p>伴随矩阵<br>Adjugate Matrix<br>Classical Adjoint Matrix<br>Adjoint Matrix 是共轭转置&#x2F;转置矩阵<br><a href="https://www.bilibili.com/video/BV1zu411D7nk/">https://www.bilibili.com/video/BV1zu411D7nk/</a></p>
<p>行列式的展开定理<br><a href="https://blog.csdn.net/li2008kui/article/details/106962868">https://blog.csdn.net/li2008kui/article/details/106962868</a></p>
<p>给定一个<code>行列式</code>，它的值等于任意一行（列）中各元素与其对应的<code>代数余子式</code>乘积之和。<br>计算行列式的公式。</p>
<p>$$<br>a_{i 1} A_{j 1}+a_{i 2} A_{j 2}+\cdots+a_{i n} A_{j n}&#x3D;\left{\begin{array}{cc}<br>|\boldsymbol{A}| &amp; i&#x3D;j \<br>0 &amp; i \neq j<br>\end{array}\right.<br>$$</p>
<p>$$<br>\left(\begin{array}{lll}<br>a_{i 1} &amp; \ldots &amp; a_{i n}<br>\end{array}\right)\left[\begin{array}{c}<br>A_{j 1} \<br>\vdots \<br>A_{j n}<br>\end{array}\right]&#x3D;\left{\begin{array}{cc}<br>|A| &amp; i&#x3D;j \<br>0 &amp; i \neq j<br>\end{array}\right.<br>$$</p>
<p>$$<br>\boldsymbol{A \boldsymbol { A } ^ { - 1 }}&#x3D;\boldsymbol{A}^{-1} \boldsymbol{A}&#x3D;\boldsymbol{E}<br>$$<br>$$<br>\boldsymbol{E}(i, j)&#x3D;\frac{1}{|\boldsymbol{A}|}<br>\left(\begin{array}{lll}<br>a_{i 1} &amp; \ldots &amp; a_{i n}<br>\end{array}\right)\left[\begin{array}{c}<br>A_{j 1} \<br>\vdots \<br>A_{j n}<br>\end{array}\right]&#x3D;\left{\begin{array}{cc}<br>|A| &amp; i&#x3D;j \<br>0 &amp; i \neq j<br>\end{array}\right.<br>$$</p>
<p>$$<br>\boldsymbol{E}&#x3D;\frac{1}{|\boldsymbol{A}|} \boldsymbol{A} \boldsymbol{A}^*<br>$$</p>
<p>$\boldsymbol{A}^*$ 就是伴随矩阵</p>
<p>利用代数余子式可以求取伴随矩阵</p>
]]></content>
  </entry>
  <entry>
    <title>body force</title>
    <url>/2023/01/01/body-force/</url>
    <content><![CDATA[<p>interFoam<br>applications&#x2F;solvers&#x2F;multiphase&#x2F;interFoam&#x2F;UEqn.H</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fvc::<span class="built_in">reconstruct</span></span><br><span class="line">(</span><br><span class="line">    (</span><br><span class="line">        mixture.<span class="built_in">surfaceTensionForce</span>()</span><br><span class="line">        - ghf*fvc::<span class="built_in">snGrad</span>(rho)</span><br><span class="line">        - fvc::<span class="built_in">snGrad</span>(p_rgh)</span><br><span class="line">    ) * mesh.<span class="built_in">magSf</span>()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="表面张力"><a href="#表面张力" class="headerlink" title="表面张力"></a>表面张力</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mixture.<span class="built_in">surfaceTensionForce</span>()</span><br></pre></td></tr></table></figure>

<p>src&#x2F;transportModels&#x2F;interfaceProperties&#x2F;interfaceProperties.C</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foam::tmp&lt;Foam::surfaceScalarField&gt;</span><br><span class="line">Foam::interfaceProperties::<span class="built_in">surfaceTensionForce</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> fvc::<span class="built_in">interpolate</span>(<span class="built_in">sigmaK</span>())*fvc::<span class="built_in">snGrad</span>(alpha1_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值是 <code>surfaceScalarField</code></p>
<h4 id="压力和重力"><a href="#压力和重力" class="headerlink" title="压力和重力"></a>压力和重力</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- <span class="function">ghf*<span class="title">fvc::snGrad</span><span class="params">(rho)</span></span></span><br><span class="line"><span class="function">- <span class="title">fvc::snGrad</span><span class="params">(p_rgh)</span></span></span><br></pre></td></tr></table></figure>

<p>#include “gh.H”<br>src&#x2F;finiteVolume&#x2F;cfdTools&#x2F;general&#x2F;include&#x2F;gh.H <code>ghf</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">dimensionedScalar <span class="title">ghRef</span><span class="params">(- mag(g)*hRef)</span></span>;</span><br><span class="line"><span class="function">volScalarField <span class="title">gh</span><span class="params">(<span class="string">&quot;gh&quot;</span>, (g &amp; mesh.C()) - ghRef)</span></span>;</span><br><span class="line"><span class="function">surfaceScalarField <span class="title">ghf</span><span class="params">(<span class="string">&quot;ghf&quot;</span>, (g &amp; mesh.Cf()) - ghRef)</span></span>;</span><br></pre></td></tr></table></figure>

<p>初始化后只和网格有关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mesh.<span class="built_in">changing</span>())</span><br><span class="line">...</span><br><span class="line">ghf = (g &amp; mesh.<span class="built_in">Cf</span>()) - ghRef;</span><br></pre></td></tr></table></figure>

<h3 id="mesh-Cf-是什么"><a href="#mesh-Cf-是什么" class="headerlink" title="mesh.Cf()是什么"></a><code>mesh.Cf()</code>是什么</h3><p>applications&#x2F;test&#x2F;mesh&#x2F;Test-mesh.C</p>
<p>复制运行 test&#x2F;fvMeshTools&#x2F;cavity<br>修改blockMesh 4×4网格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blockMesh</span><br><span class="line">nohup Test-mesh &gt;log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<h4 id="mesh-C"><a href="#mesh-C" class="headerlink" title="mesh.C()"></a>mesh.C()</h4><p>dimensions      [0 1 0 0 0 0 0];<br>网格的中心和边界的中心</p>
<h4 id="mesh-V"><a href="#mesh-V" class="headerlink" title="mesh.V()"></a>mesh.V()</h4><p>dimensions      [0 3 0 0 0 0 0];<br>网格的体积</p>
<h4 id="mesh-Cf"><a href="#mesh-Cf" class="headerlink" title="mesh.Cf()"></a>mesh.Cf()</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dimensions      [0 1 0 0 0 0 0]</span><br><span class="line">internalField   nonuniform List&lt;vector&gt; </span><br><span class="line">boundaryField</span><br></pre></td></tr></table></figure>
<p>内部面的面心<br>边界面的面心</p>
]]></content>
  </entry>
  <entry>
    <title>Github+Hexo搭建个人博客</title>
    <url>/2022/11/08/build-blog-with-Github-Hexo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要用于记录建立个人博客过程。高手不用看，新手看不懂。  </p>
<p>采用Github+Hexo的模式，原因是不用注册域名和服务器，博客暂时比较简单，目前没精力仔细布置。</p>
<h3 id="本地准备工作"><a href="#本地准备工作" class="headerlink" title="本地准备工作"></a>本地准备工作</h3><p>安装Git<br><a href="https://git-scm.com/download/">https://git-scm.com/download/</a></p>
<p>安装node.js<br><a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>首先建立同名仓库</p>
<p>github → settings → SSH and GPG keys 添加本地的 id_rsa.pub</p>
<p>本地操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>在文件夹内右键 <code>Git Bash Here</code>  </p>
<p><img src="/2022/11/08/build-blog-with-Github-Hexo/Git_Bash_Here.png" alt="Git Bash Here"></p>
<p><img src="/2022/11/08/build-blog-with-Github-Hexo/Git_Bash.png" alt="Git Bash"></p>
<p>在Git Bash中输入以下命令安装Hexo  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>修改<code>_config.yml</code>配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/na-an/na-an.github.io/</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p>基本操作</p>
<p>清除缓存，每次修改配置文件后都要执行该命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>生成静态网页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>本地预览</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>向仓库推送文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>新建文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;article title&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/yaorongke/article/details/119089190">CSDN GitHub Pages + Hexo搭建个人博客网站，史上最全教程</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/269420507">知乎 利用Gitee+Hexo搭建个人网站</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35668237">知乎 超详细Hexo+Github博客搭建小白教程</a></p>
]]></content>
  </entry>
  <entry>
    <title>calculus</title>
    <url>/2023/01/04/calculus/</url>
    <content><![CDATA[<p>乘积法则，莱布尼兹法则<br><a href="https://zh.wikipedia.org/wiki/%E4%B9%98%E7%A7%AF%E6%B3%95%E5%88%99">https://zh.wikipedia.org/wiki/%E4%B9%98%E7%A7%AF%E6%B3%95%E5%88%99</a></p>
]]></content>
  </entry>
  <entry>
    <title>convection diffusion</title>
    <url>/2023/01/12/convection-diffusion/</url>
    <content><![CDATA[<p>一维对流扩散方程的Dirichlet精确解<br><a href="https://cloud.tencent.com/developer/article/2012325">https://cloud.tencent.com/developer/article/2012325</a></p>
<p><img src="/2023/01/12/convection-diffusion/special.png" alt="special"></p>
<p>第五章 对流-扩散方程的离散格式<br><a href="http://gr.xjtu.edu.cn/c/document_library/get_file?folderId=2231676&amp;name=DLFE-79332.pdf">http://gr.xjtu.edu.cn/c/document_library/get_file?folderId=2231676&amp;name=DLFE-79332.pdf</a></p>
<p>&lt;低Peclet数下剪切流中气溶胶粒子的传质率&gt;<br>10.3878&#x2F;j.issn.1006-9895.1994.01.13</p>
<h3 id="看，暂时先关"><a href="#看，暂时先关" class="headerlink" title="看，暂时先关"></a>看，暂时先关</h3><p>Navier-Stokes 方程的正则性1：引言（学数学与物理的小伙伴请进）<br><a href="https://zhuanlan.zhihu.com/p/259422910">https://zhuanlan.zhihu.com/p/259422910</a></p>
<p>CFD入门：一维线性对流方程<br><a href="https://gitee.com/laser2000/CFD_Fundamental">https://gitee.com/laser2000/CFD_Fundamental</a><br><a href="https://zhuanlan.zhihu.com/p/92149491">https://zhuanlan.zhihu.com/p/92149491</a></p>
<p>一维常系数对流方程的学习——来自流沙公众号<br><a href="https://blog.csdn.net/qq_42000453/article/details/82846034">https://blog.csdn.net/qq_42000453/article/details/82846034</a></p>
<p>有限体积法（29）对流项离散（10）二维稳态对流问题<br><a href="https://zhuanlan.zhihu.com/p/373252419">https://zhuanlan.zhihu.com/p/373252419</a></p>
<p>扩散、对流和反应模型中，浓度为什么会出现负值？<br><a href="https://zhuanlan.zhihu.com/p/269891903">https://zhuanlan.zhihu.com/p/269891903</a><br>(有界性)</p>
<p>提高非线性稳态模型的收敛性<br><a href="http://cn.comsol.com/support/knowledgebase/103">http://cn.comsol.com/support/knowledgebase/103</a></p>
<p>不同边界条件的收敛要求。<br>进出口都是第一类：Pelect (F&#x2F;D&#x2F;dx）<br>进口第一类，出口第二类。</p>
<p>Artificial Diffusion | 假扩散<br><a href="https://www.cfd-china.com/topic/2229/artificial-diffusion-%E5%81%87%E6%89%A9%E6%95%A3">https://www.cfd-china.com/topic/2229/artificial-diffusion-%E5%81%87%E6%89%A9%E6%95%A3</a></p>
<p>一种新的求解对流占优问题的自适应网格细化方法<br><a href="https://pubs.cstam.org.cn/data/article/cjcm/preview/pdf/20190503.pdf">https://pubs.cstam.org.cn/data/article/cjcm/preview/pdf/20190503.pdf</a></p>
<p>对流扩散方程与 N-S 方程之间有什么联系？<br><a href="https://www.zhihu.com/question/263374306">https://www.zhihu.com/question/263374306</a></p>
<p>可压双曲 不可压抛物 </p>
<p>扩散方程 椭圆 Laplace方程(又称调和方程)和Poisson方程</p>
<p>PDE有限差分方法(10)——边界条件离散方法<br><a href="https://zhuanlan.zhihu.com/p/149680131">https://zhuanlan.zhihu.com/p/149680131</a></p>
<p>有限体积版本的 SUPG streamline upwind Petrov-Galerkin<br><a href="https://www.cfd-online.com/Forums/main/2428-finite-volume-version-supg.html">https://www.cfd-online.com/Forums/main/2428-finite-volume-version-supg.html</a></p>
<p>中心差分（CDS），QUICK，上风和MUSCL方案（使用通量限制器）<br><a href="https://www.cfd-online.com/Forums/main/245976-solving-2d-convection-diffusion-equation-using-finite-volume-method-matlab.html">https://www.cfd-online.com/Forums/main/245976-solving-2d-convection-diffusion-equation-using-finite-volume-method-matlab.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>doxygen</title>
    <url>/2023/01/05/doxygen/</url>
    <content><![CDATA[<p><a href="https://cpp.openfoam.org/v7/graph_legend.html">https://cpp.openfoam.org/v7/graph_legend.html</a></p>
<p><a href="https://blog.csdn.net/benkaoya/article/details/79763668">https://blog.csdn.net/benkaoya/article/details/79763668</a></p>
<p><a href="https://blog.csdn.net/xiamentingtao/article/details/49722007">https://blog.csdn.net/xiamentingtao/article/details/49722007</a></p>
<p><a href="https://developer.aliyun.com/article/227074">https://developer.aliyun.com/article/227074</a></p>
]]></content>
  </entry>
  <entry>
    <title>dynamicMesh</title>
    <url>/2023/01/13/dynamicMesh/</url>
    <content><![CDATA[<p>constant&#x2F;dynamicMeshDict</p>
<p>初始OpenFOAM动网格<br><a href="https://zhuanlan.zhihu.com/p/394740427">https://zhuanlan.zhihu.com/p/394740427</a></p>
<p>OpenFOAM自适应网格加密算例<br><a href="https://zhuanlan.zhihu.com/p/482791084">https://zhuanlan.zhihu.com/p/482791084</a></p>
<p>在OpenFOAM中实现动网格与流场的信息交互<br><a href="https://zhuanlan.zhihu.com/p/555931477">https://zhuanlan.zhihu.com/p/555931477</a><br>自适应关键词<br>dynamicRefineFvMesh</p>
<p><img src="/2023/01/13/dynamicMesh/dynamicMesh.png" alt="dynamicMesh"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -name dynamicMeshDict</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find $FOAM_TUTORIALS -type f | xargs grep -sl &#x27;dynamicRefineFvMesh&#x27;</span><br></pre></td></tr></table></figure>

<p><a href="https://holzmann-cfd.com/community/training-cases/adaptive-mesh-refinement">https://holzmann-cfd.com/community/training-cases/adaptive-mesh-refinement</a></p>
<p>interDyMFoam  已经被移除了</p>
<p><a href="https://github.com/krajit/dynamicRefine2DFvMesh.git">https://github.com/krajit/dynamicRefine2DFvMesh.git</a><br>2D 自适应，需要额外安装</p>
<p>头文件</p>
]]></content>
  </entry>
  <entry>
    <title>easyCFD</title>
    <url>/2022/12/31/easyCFD/</url>
    <content><![CDATA[<h3 id="Eigen"><a href="#Eigen" class="headerlink" title="Eigen"></a>Eigen</h3><h4 id="Eigen-下载解压"><a href="#Eigen-下载解压" class="headerlink" title="Eigen 下载解压"></a>Eigen 下载解压</h4><p>Eigen 是 header-only 的，所以直接下载 Eigen 头文件即可使用</p>
<p>Qt 的 pro文件 中添加<br>INCLUDEPATH     +&#x3D;  D:\eigen-3.4.0\Eigen  </p>
<p>eigenTest  </p>
<p>安装<br><a href="https://blog.csdn.net/onlyonelt/article/details/105820668">https://blog.csdn.net/onlyonelt/article/details/105820668</a><br><a href="https://developer.aliyun.com/article/943682">https://developer.aliyun.com/article/943682</a></p>
<h3 id="eigen-求解方程"><a href="#eigen-求解方程" class="headerlink" title="eigen 求解方程"></a>eigen 求解方程</h3><p>Eigen语法记录<br><a href="https://dritchie.github.io/csci2240/assignments/eigen_tutorial.pdf">https://dritchie.github.io/csci2240/assignments/eigen_tutorial.pdf</a></p>
<p><a href="https://eigen.tuxfamily.org/dox/group__QuickRefPage.html">https://eigen.tuxfamily.org/dox/group__QuickRefPage.html</a></p>
<p><a href="https://yearn.xyz/posts/tools/eigen-3.3.7-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">https://yearn.xyz/posts/tools/eigen-3.3.7-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/573069585">https://zhuanlan.zhihu.com/p/573069585</a></p>
<p><a href="https://gaoyichao.com/Xiaotu/?book=eigen&amp;title=chapter1">https://gaoyichao.com/Xiaotu/?book=eigen&amp;title=chapter1</a></p>
<p><a href="https://blog.csdn.net/weixin_42691752/article/details/88950818">https://blog.csdn.net/weixin_42691752/article/details/88950818</a><br><a href="https://github.com/1751200/Xlab-k8s-gpu/blob/master/Report/report3/">https://github.com/1751200/Xlab-k8s-gpu/blob/master/Report/report3/</a></p>
<h4 id="建立矩阵"><a href="#建立矩阵" class="headerlink" title="建立矩阵"></a>建立矩阵</h4><p>Eigen学习（六）高级初始化<br><a href="https://blog.csdn.net/u012936940/article/details/79830267">https://blog.csdn.net/u012936940/article/details/79830267</a></p>
<h4 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h4><p>矩阵分解。原文写的足够好，此处做拷贝。<br><a href="https://www.cnblogs.com/feifanrensheng/articles/8510702.html">https://www.cnblogs.com/feifanrensheng/articles/8510702.html</a><br><a href="http://zhaoxuhui.top/blog/2019/08/22/eigen-note-2.html">http://zhaoxuhui.top/blog/2019/08/22/eigen-note-2.html</a><br><a href="https://www.aintk.xyz/post/2018-09-18-eigenusage2/">https://www.aintk.xyz/post/2018-09-18-eigenusage2/</a><br><a href="https://www.guyuehome.com/40268">https://www.guyuehome.com/40268</a><br><a href="https://www.zybuluo.com/gunshooter/note/1500640">https://www.zybuluo.com/gunshooter/note/1500640</a><br><a href="https://gaoyichao.com/Xiaotu/?book=eigen&amp;title=chapter1">https://gaoyichao.com/Xiaotu/?book=eigen&amp;title=chapter1</a></p>
<p>矩阵分解 (decomposition, factorization)是将矩阵拆解为数个矩阵的乘积，可分为三角分解、满秩分解、QR分解、Jordan分解和SVD（奇异值）分解等，常见的有三种：1)三角分解法 (Triangular Factorization)，2)QR 分解法 (QR Factorization)，3)奇异值分解法 (Singular Value Decompostion)。</p>
<ol>
<li>LU三角分解：</li>
</ol>
<p>三角分解法是将原正方 (square) 矩阵分解成一个上三角形矩阵　或是排列(permuted) 的上三角形矩阵和一个 下三角形矩阵，这样的分解法又称为LU分解法。它的用途主要在简化一个大矩阵的行列式值的计算过程，求 反矩阵，和求解联立方程组。不过要注意这种分解法所得到的上下三角形矩阵并非唯一，还可找到数个不同 的一对上下三角形矩阵，此两三角形矩阵相乘也会得到原矩阵。<br>MATLAB以lu函数来执行lu分解法， 其语法为[L,U]&#x3D;lu(A)。</p>
<ol start="2">
<li>QR分解：</li>
</ol>
<p>QR分解法是将矩阵分解成一个正规正交矩阵与上三角形矩阵,所以称为QR分解法,与此正规正交矩阵的通用符号Q有关。<br>MATLAB以qr函数来执行QR分解法， 其语法为[Q,R]&#x3D;qr(A)。</p>
<ol start="3">
<li>奇异值分解：</li>
</ol>
<p>奇异值分解 (singular value decomposition,SVD) 是另一种正交矩阵分解法；SVD是最可靠的分解法，但是它比QR 分解法要花上近十倍的计算时间。[U,S,V]&#x3D;svd(A)，其中U和V分别代表两个正交矩阵，而S代表一对角矩阵。 和QR分解法相同， 原矩阵A不必为正方矩阵。使用SVD分解法的用途是解最小平方误差法和数据压缩。<br>MATLAB以svd函数来执行svd分解法， 其语法为[S,V,D]&#x3D;svd(A)。</p>
<ol start="4">
<li>LLT分解：</li>
</ol>
<p>A&#x3D;LL^T</p>
<p>Cholesky 分解是把一个对称正定的矩阵表示成一个下三角矩阵L和其转置的乘积的分解。它要求矩阵的所有特征值必须大于零，故分解的下三角的对角元也是大于零的（LU三角分解法的变形）。</p>
<ol start="5">
<li>LDLT分解法：</li>
</ol>
<p>若A为一对称矩阵且其任意一k阶主子阵均不为零，则A有如下惟一的分解形式：</p>
<p>A&#x3D;LDL^T<br>其中L为一下三角形单位矩阵（即主对角线元素皆为1），D为一对角矩阵（只在主对角线上有元素，其余皆为零），L^T为L的转置矩阵。<br>LDLT分解法实际上是Cholesky分解法的改进，因为Cholesky分解法虽然不需要选主元，但其运算过程中涉及到开方问题，而LDLT分解法则避免了这一问题，可用于求解线性方程组。</p>
<h3 id="FVM"><a href="#FVM" class="headerlink" title="FVM"></a>FVM</h3><p>有限体积法（4）——一维扩散方程数值求解（第二类边界条件）</p>
<p><a href="https://blog.csdn.net/weixin_42562856/article/details/106838206">https://blog.csdn.net/weixin_42562856/article/details/106838206</a></p>
]]></content>
  </entry>
  <entry>
    <title>fvm</title>
    <url>/2023/01/11/fvm/</url>
    <content><![CDATA[<p>有限体积法（4）——一维扩散方程数值求解（第二类边界条件）</p>
<p><a href="https://blog.csdn.net/weixin_42562856/article/details/106838206">https://blog.csdn.net/weixin_42562856/article/details/106838206</a></p>
<p><a href="https://nht.xjtu.edu.cn/jxzy/szcrx/9.htm">https://nht.xjtu.edu.cn/jxzy/szcrx/9.htm</a></p>
<p>（CFD）投影法求解二维不可压缩N-S方程<br><a href="https://blog.csdn.net/weixin_43921223/article/details/107485254">https://blog.csdn.net/weixin_43921223/article/details/107485254</a></p>
]]></content>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/12/07/git/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure>

<p>查看本地 git 配置的用户名和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>

<p>修改用户名和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list  </span><br></pre></td></tr></table></figure>


<h3 id="gitee"><a href="#gitee" class="headerlink" title="gitee"></a>gitee</h3><p>gitee 新建仓库后有简易的命令行入门教程</p>
<p>Git全局设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;jian&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>创建git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> CS106B_Work</span><br><span class="line"><span class="built_in">cd</span> CS106B_Work</span><br><span class="line">git init </span><br><span class="line"><span class="built_in">touch</span> README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git remote add origin https://gitee.com/na_jian/CS106B_Work.git</span><br><span class="line">git push -u origin <span class="string">&quot;master&quot;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:jian/CS106B_Work.git</span><br><span class="line">error: remote origin already exists</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin  https://gitee.com/na_jian/CS106B_Work.git (fetch)</span><br><span class="line">origin  https://gitee.com/na_jian/CS106B_Work.git (push)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br><span class="line">bash: $<span class="string">&#x27;\302\203git&#x27;</span>: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>$ git push<br>fatal: The current branch master has no upstream branch.<br>To push the current branch and set the remote as upstream, use</p>
<pre><code>git push --set-upstream origin master
</code></pre>
<p>git push –set-upstream origin master</p>
<p>新增提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git push -u origin &quot;master&quot;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/02/08/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>how to use Hexo</title>
    <url>/2022/11/11/how-to-use-Hexo/</url>
    <content><![CDATA[<h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><p>修改配置文件 _config.yml，post_asset_folder 改为 true， 添加marked </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>添加图片的方法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">名称</span>](<span class="link">文件名</span>)</span><br></pre></td></tr></table></figure>

<h3 id="代码去掉行号"><a href="#代码去掉行号" class="headerlink" title="代码去掉行号"></a>代码去掉行号</h3><p>修改配置文件_config.yml，line_number: true 改成 false  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="换电脑"><a href="#换电脑" class="headerlink" title="换电脑"></a>换电脑</h3><p>网页上显示的其他方法是同步source。<br>复制所有文件，在另一台电脑上安装Hexo即可。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>建立RSS订阅</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<h3 id="NexT主题"><a href="#NexT主题" class="headerlink" title="NexT主题"></a>NexT主题</h3><p>安装NexT主题，卸载默认的landscape主题  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br><span class="line">npm uninstall hexo-theme-landscape</span><br></pre></td></tr></table></figure>

<p>删除 _config.landscape.yml 文件，将 node_modules&#x2F;hexo-theme-next&#x2F;_config.yml 文件复制到主目录，改名为_config.next.yml</p>
<h4 id="不蒜子网页计数器功能"><a href="#不蒜子网页计数器功能" class="headerlink" title="不蒜子网页计数器功能"></a>不蒜子网页计数器功能</h4><p>busuanzi_count<br>在_config.next.yml 里找到 busuanzi_count，将其打开</p>
<h4 id="Local-Search-搜索功能"><a href="#Local-Search-搜索功能" class="headerlink" title="Local Search 搜索功能"></a>Local Search 搜索功能</h4><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>在配置文件_config.yml 加入：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>百度统计</p>
<p>参考<br><a href="https://bambrow.com/20211125-hexo-blog-guide/">https://bambrow.com/20211125-hexo-blog-guide/</a><br><a href="https://theme-next.iissnan.com/getting-started.html">https://theme-next.iissnan.com/getting-started.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>learn OpenFOAM</title>
    <url>/2022/12/30/learn-OpenFOAM/</url>
    <content><![CDATA[<p><a href="https://github.com/UnnamedMoose/BasicOpenFOAMProgrammingTutorials.git">https://github.com/UnnamedMoose/BasicOpenFOAMProgrammingTutorials.git</a></p>
<p><a href="https://github.com/k323r/programming-openfoam.git">https://github.com/k323r/programming-openfoam.git</a></p>
<p><a href="http://gezhu.github.io/">http://gezhu.github.io/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git://git.code.sf.net/p/foam-extend/foam-extend-3.2 foam-extend-foam-extend-3.2</span><br></pre></td></tr></table></figure>

<p><a href="https://q8frym1nsp.feishu.cn/docx/FIg5dgAk0oD0o9xo8bpc9knonUf">https://q8frym1nsp.feishu.cn/docx/FIg5dgAk0oD0o9xo8bpc9knonUf</a></p>
<p><a href="https://zhulianhua.github.io/2016/09/28/OpenFOAM-Learning-Resources/">https://zhulianhua.github.io/2016/09/28/OpenFOAM-Learning-Resources/</a></p>
<p><a href="https://www.cfd-china.com/topic/3499/openfoam%E5%B0%8F%E4%BB%A3%E7%A0%81">https://www.cfd-china.com/topic/3499/openfoam%E5%B0%8F%E4%BB%A3%E7%A0%81</a></p>
]]></content>
  </entry>
  <entry>
    <title>parallel</title>
    <url>/2022/11/23/parallel/</url>
    <content><![CDATA[<h3 id="OpenFOAM"><a href="#OpenFOAM" class="headerlink" title="OpenFOAM"></a>OpenFOAM</h3><p>Install general packages for OpenFOAM</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install flex libfl-dev bison zlib1g-dev libboost-system-dev libboost-thread-dev libopenmpi-dev openmpi-bin gnuplot libreadline-dev libncurses-dev libxt-dev</span><br></pre></td></tr></table></figure>

<p>其中包含openMPI的安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">libopenmpi-dev openmpi-bin</span><br></pre></td></tr></table></figure>


<p>OpenFOAM的描述 <a href="#1"><sup>1</sup></a><br>This section describes how to run OpenFOAM in parallel on distributed processors. The method of parallel computing used by OpenFOAM is known as domain decomposition, in which the geometry and associated fields are broken into pieces and allocated to separate processors for solution. The process of parallel computation involves: decomposition of mesh and fields; running the application in parallel; and, post-processing the decomposed case as described in the following sections. The parallel running uses the public domain <em><strong>openMPI</strong></em> implementation of the standard message passing interface (MPI) by default, although other libraries can be used.  </p>
<p>message passing interface 消息传递接口</p>
<p>MPI 比大多数并行框架要更底层（比如 Hadoop）</p>
<p>OpenFOAM 使用的并行计算方法为计算域分解法。在这个方法中，几何和附属场被拆分为单独的块，每个块用单独的cpu 来进行计算。<a href="#2"><sup>2</sup></a></p>
<h3 id="openMPI"><a href="#openMPI" class="headerlink" title="openMPI"></a>openMPI</h3><p>查询版本信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpirun --version</span><br><span class="line">mpirun (Open MPI) 4.0.3</span><br><span class="line">mpiexec --version</span><br><span class="line">mpiexec (OpenRTE) 4.0.3</span><br></pre></td></tr></table></figure>

<p>mpirun (Open MPI) 4.0.3</p>
<p>Report bugs to <a href="http://www.open-mpi.org/community/help/">http://www.open-mpi.org/community/help/</a></p>
<h3 id="MPI、OpenMP、OpenMPI"><a href="#MPI、OpenMP、OpenMPI" class="headerlink" title="MPI、OpenMP、OpenMPI"></a>MPI、OpenMP、OpenMPI</h3><p><a href="https://www.jianshu.com/p/13695983be44">https://www.jianshu.com/p/13695983be44</a></p>
<h3 id="程序改写"><a href="#程序改写" class="headerlink" title="程序改写"></a>程序改写</h3><h3 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h3><p><a href="https://mpitutorial.com/tutorials/">https://mpitutorial.com/tutorials/</a></p>
<p><a href="https://github.com/parallel101/course">https://github.com/parallel101/course</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><div id="1"></div>

<ul>
<li>[1] <a href="https://doc.cfd.direct/openfoam/user-guide-v10/running-applications-parallel">OpenFOAM v10 User Guide - 3.4 Running applications in parallel</a></li>
</ul>
<div id="2"></div>

<ul>
<li>[2] <a href="http://www.dyfluid.com/OpenFOAM%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-9.pdf">OpenFOAM用户指南-9</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>plot</title>
    <url>/2023/02/02/plot/</url>
    <content><![CDATA[<p>C++ 可视化</p>
<p>C++可视化库推荐<br><a href="https://blog.csdn.net/chyuanrufeng/article/details/102808715">https://blog.csdn.net/chyuanrufeng/article/details/102808715</a></p>
]]></content>
  </entry>
  <entry>
    <title>relax</title>
    <url>/2022/12/01/relax/</url>
    <content><![CDATA[<p>XEqn.relax();</p>
<p>X.relax();</p>
<p>&#x2F;src&#x2F;finiteVolume&#x2F;fvMatrices&#x2F;fvMatrix&#x2F;fvMatrix.H</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- Relax matrix (for steady-state solution).</span></span><br><span class="line"><span class="comment">//  alpha = 1 : diagonally equal</span></span><br><span class="line"><span class="comment">//  alpha &lt; 1 : diagonally dominant</span></span><br><span class="line"><span class="comment">//  alpha = 0 : do nothing</span></span><br><span class="line"><span class="comment">//  Note: Requires positive diagonal.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relax</span><span class="params">(<span class="type">const</span> scalar alpha)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- Relax matrix (for steady-state solution).</span></span><br><span class="line"><span class="comment">//  alpha is read from controlDict</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relax</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>有两种实现，一种是缺省值，一种指定alpha</p>
<p>缺省值<br>relax(psi_.mesh().equationRelaxationFactor(psi_.name()));</p>
<p>&#x2F;src&#x2F;OpenFOAM&#x2F;matrices&#x2F;solution&#x2F;solution.C<br>Foam::scalar Foam::solution::equationRelaxationFactor(const word&amp; name) const</p>
<p>return eqnRelaxDefault_;</p>
<p>solution.H</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- Dictionary of relaxation factors for all the equations</span></span><br><span class="line">dictionary eqnRelaxDict_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- Optional default relaxation factor for all the fields</span></span><br><span class="line">scalar fieldRelaxDefault_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- Optional default relaxation factor for all the equations</span></span><br><span class="line">scalar eqnRelaxDefault_;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dict.<span class="built_in">found</span>(<span class="string">&quot;relaxationFactors&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">eqnRelaxDefault_ =</span><br><span class="line">            eqnRelaxDict_.<span class="built_in">lookupOrDefault</span>&lt;scalar&gt;(<span class="string">&quot;default&quot;</span>, <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>
<p>eqnRelaxDict_ 是 dictionary 类；</p>
<p>&#x2F;src&#x2F;OpenFOAM&#x2F;db&#x2F;dictionary&#x2F;dictionary.H</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- Find and return a T,</span></span><br><span class="line"><span class="comment">//  if not found return the given default value.</span></span><br><span class="line"><span class="comment">//  If recursive, search parent dictionaries.</span></span><br><span class="line"><span class="comment">//  If patternMatch, use regular expressions.</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">lookupOrDefault</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> word&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> T&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> recursive=<span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> patternMatch=<span class="literal">true</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>lookupOrDefault 作用是返回值，如果没有值，采用默认值，即如果没有给 relaxationFactors, 就是 0 。</p>
<p>在计算中修改void relax(const scalar alpha) 规定松弛因子。</p>
]]></content>
  </entry>
  <entry>
    <title>ssh</title>
    <url>/2022/12/02/ssh/</url>
    <content><![CDATA[<p>用ssh远程连接需要配置服务端和客户端</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>一般Ubuntu都会默认安装openssh-client, 但是没有安装openssh-server。<br>安装ssh服务器  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>

<p>检查是否启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -e | grep ssh</span><br></pre></td></tr></table></figure>
<p>出现sshd ssh-server 即启动</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="命令行连接"><a href="#命令行连接" class="headerlink" title="命令行连接"></a>命令行连接</h4><p>例如用Windows的cmd, Linux的terminal<br>命令行输入 <code>ssh -V</code> 或 <code>ssh</code> 验证本地已经安装ssh  </p>
<p>命令行进行连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh username@ip</span><br></pre></td></tr></table></figure>
<p>之后输入密码进行登陆</p>
<h4 id="VSCode-连接"><a href="#VSCode-连接" class="headerlink" title="VSCode 连接"></a>VSCode 连接</h4><p><strong>1. 安装Remote-SSH插件</strong>  </p>
<p><img src="/2022/12/02/ssh/remote-SSH.png" alt="Remote-SSH插件"><br><img src="/2022/12/02/ssh/config.png" alt="config配置文件"><br><img src="/2022/12/02/ssh/config_2.png" alt="config配置文件"></p>
<p>config 位置在用户的.ssh文件夹内</p>
<p>config 文件中配置HostName和user，远程服务器的ip和username  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host 自定义</span><br><span class="line">  HostName ip</span><br><span class="line">  User username</span><br></pre></td></tr></table></figure>

<p>这样VSCode 就能连接远程服务器。但是每次打开不同的文件和文件夹都需要重新输入密码，因此采用免密登陆的方法。</p>
<p><strong>2. 生成密钥对免密登录</strong> </p>
<p><strong>① 在客户端命令行执行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>在执行命令的文件夹下生成.ssh文件夹，里面包含id_rsa.pub</p>
<p><strong>② 在服务端添加密钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> .ssh <span class="comment">#新建.ssh文件夹</span></span><br><span class="line"><span class="built_in">cd</span> .ssh/ <span class="comment">#进入.ssh文件夹</span></span><br><span class="line"><span class="built_in">touch</span> authorized_keys <span class="comment"># 新建authorized_keys文件</span></span><br><span class="line">code authorized_keys <span class="comment"># 打开后，粘贴id_rsa.pub内容到authorized_keys</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 600 authorized_keys <span class="comment">#变成可读写文件</span></span><br><span class="line">service sshd restart <span class="comment">#重启ssh</span></span><br></pre></td></tr></table></figure>

<p>以后每次VSCode打开远程文件或文件夹都不需要重新输入密码</p>
<p>code是Vscode打开authorized_keys<br>或者在命令行工具vim authorized_keys修改 </p>
<p>vscode 更新后，如果连接不上，删除服务器主目录下的.vscode-server&#x2F;文件夹。</p>
]]></content>
  </entry>
</search>
